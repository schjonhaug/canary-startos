import { Parser } from "./index";
import { IParser, OnParse } from "./interfaces";
type _<T> = T;
export type MergeAll<T> = T extends Array<infer U> ? Array<MergeAll<U>> : T extends object ? T extends null | undefined | never ? T : _<{
    [k in keyof T]: MergeAll<T[k]>;
}> : T;
/**
 * Given an object, we want to make sure the key exists and that the value on
 * the key matches the parser
 */
export declare class ShapeParser<A extends unknown, Key extends string | number | symbol, B> implements IParser<A, B> {
    readonly parserMap: {
        [key in keyof B]: Parser<unknown, B[key]>;
    };
    readonly isPartial: boolean;
    readonly parserKeys: Array<string & keyof B>;
    readonly description: {
        readonly name: "Partial" | "Shape";
        readonly children: { [key in keyof B]: Parser<unknown, B[key]>; }[string & keyof B][];
        readonly extras: (string & keyof B)[];
    };
    constructor(parserMap: {
        [key in keyof B]: Parser<unknown, B[key]>;
    }, isPartial: boolean, parserKeys?: Array<string & keyof typeof parserMap>, description?: {
        readonly name: "Partial" | "Shape";
        readonly children: { [key in keyof B]: Parser<unknown, B[key]>; }[string & keyof B][];
        readonly extras: (string & keyof B)[];
    });
    parse<C, D>(a: A, onParse: OnParse<A, B, C, D>): C | D;
}
export declare const isPartial: <A extends {}>(testShape: { [key in keyof A]: Parser<unknown, A[key]>; }) => Parser<unknown, Partial<A>>;
/**
 * Good for duck typing an object, with optional values
 * @param testShape Shape of validators, to ensure we match the shape
 */
export declare const partial: <A extends {}>(testShape: { [key in keyof A]: Parser<unknown, A[key]>; }) => Parser<unknown, Partial<A>>;
/**
 * Good for duck typing an object
 * @param testShape Shape of validators, to ensure we match the shape
 */
export declare const isShape: <A extends {}>(testShape: { [key in keyof A]: Parser<unknown, A[key]>; }) => Parser<unknown, A>;
export type OptionalKeys<Obj extends {}> = {
    [K in keyof Obj]: undefined extends Obj[K] ? K : never;
}[keyof Obj];
export type WithOptionalKeys<Obj extends {}> = MergeAll<{
    [K in keyof Omit<Obj, OptionalKeys<Obj>>]: Obj[K];
} & {
    [K in OptionalKeys<Obj>]?: Obj[K];
}>;
export declare function shape<A extends {}>(testShape: {
    [key in keyof A]: Parser<unknown, A[key]>;
}): Parser<unknown, WithOptionalKeys<A>>;
export {};
