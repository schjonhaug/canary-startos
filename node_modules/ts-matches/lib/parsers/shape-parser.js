"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isShape = exports.partial = exports.isPartial = exports.ShapeParser = void 0;
exports.shape = shape;
const index_1 = require("./index");
const utils_1 = require("../utils");
/**
 * Given an object, we want to make sure the key exists and that the value on
 * the key matches the parser
 */
class ShapeParser {
    parserMap;
    isPartial;
    parserKeys;
    description;
    constructor(parserMap, isPartial, parserKeys = Object.keys(parserMap), description = {
        name: isPartial ? "Partial" : "Shape",
        children: parserKeys.map((key) => parserMap[key]),
        extras: parserKeys,
    }) {
        this.parserMap = parserMap;
        this.isPartial = isPartial;
        this.parserKeys = parserKeys;
        this.description = description;
    }
    parse(a, onParse) {
        const parser = this;
        if (!index_1.object.test(a)) {
            return onParse.invalid({
                value: a,
                keys: [],
                parser,
            });
        }
        const { parserMap, isPartial, parserKeys } = this;
        const value = { ...a };
        if (Array.isArray(a)) {
            value.length = a.length;
        }
        for (const key of parserKeys) {
            if (key in value) {
                const parser = parserMap[key];
                const state = parser.enumParsed(a[key]);
                if ("error" in state) {
                    const { error } = state;
                    error.keys.push((0, utils_1.saferStringify)(key));
                    return onParse.invalid(error);
                }
                const smallValue = state.value;
                value[key] = smallValue;
            }
            else if (!isPartial) {
                return onParse.invalid({
                    value: "missingProperty",
                    parser,
                    keys: [(0, utils_1.saferStringify)(key)],
                });
            }
        }
        return onParse.parsed(value);
    }
}
exports.ShapeParser = ShapeParser;
const isPartial = (testShape) => {
    return new index_1.Parser(new ShapeParser(testShape, true));
};
exports.isPartial = isPartial;
/**
 * Good for duck typing an object, with optional values
 * @param testShape Shape of validators, to ensure we match the shape
 */
exports.partial = exports.isPartial;
/**
 * Good for duck typing an object
 * @param testShape Shape of validators, to ensure we match the shape
 */
const isShape = (testShape) => {
    return new index_1.Parser(new ShapeParser(testShape, false));
};
exports.isShape = isShape;
function shape(testShape) {
    const entries = Object.entries(testShape || {});
    const [full, partials] = entries.reduce(([full, partials], [key, parser]) => parser.retryable() ?
        [full, [...partials, [key, parser]]]
        : [[...full, [key, parser]], partials], [[], []]);
    if (!partials.length) {
        return (0, exports.isShape)(testShape || {});
    }
    else {
        const partialParser = (0, exports.partial)(Object.fromEntries(partials)).map((ret) => {
            for (const [key, parser] of partials) {
                const keyAny = key;
                if (!(keyAny in ret)) {
                    const newValue = parser.unsafeCast(undefined);
                    if (newValue !== undefined) {
                        ret[keyAny] = newValue;
                    }
                }
            }
            return ret;
        });
        if (!full.length) {
            return partialParser;
        }
        else {
            return (0, index_1.every)(partialParser, (0, exports.isShape)(Object.fromEntries(full)));
        }
    }
}
//# sourceMappingURL=shape-parser.js.map