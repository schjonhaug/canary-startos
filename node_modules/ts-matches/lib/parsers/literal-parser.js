"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiteralsParser = void 0;
exports.literal = literal;
exports.literals = literals;
const parser_1 = require("./parser");
function eq(a, b) {
    if (a === b) {
        return true;
    }
    if (a === null) {
    }
    if (typeof a === "object" && typeof b === "object") {
        if (Array.isArray(a) && Array.isArray(b)) {
            if (a.length === b.length) {
                return a.findIndex((a, idx) => !eq(a, b[idx])) === -1;
            }
        }
        else if (a && b && !Array.isArray(a) && !Array.isArray(b)) {
            return eq(Object.entries(a).sort(([a, _a], [b, _b]) => a.localeCompare(b)), Object.entries(b).sort(([a, _a], [b, _b]) => a.localeCompare(b)));
        }
    }
    return false;
}
class LiteralsParser {
    values;
    description;
    constructor(values, description = {
        name: "Literal",
        children: [],
        extras: values,
    }) {
        this.values = values;
        this.description = description;
    }
    parse(a, onParse) {
        for (const value of this.values) {
            if (eq(value, a))
                return onParse.parsed(a);
        }
        return onParse.invalid({
            value: a,
            keys: [],
            parser: this,
        });
    }
}
exports.LiteralsParser = LiteralsParser;
function literal(isEqualToValue) {
    return new parser_1.Parser(new LiteralsParser([isEqualToValue]));
}
function literals(firstValue, ...restValues) {
    return new parser_1.Parser(new LiteralsParser([firstValue, ...restValues]));
}
//# sourceMappingURL=literal-parser.js.map