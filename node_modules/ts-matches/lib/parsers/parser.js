"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parser = void 0;
const index_1 = require("./index");
const utils_1 = require("../utils");
const any_parser_1 = require("./any-parser");
const array_parser_1 = require("./array-parser");
const bool_parser_1 = require("./bool-parser");
const concat_parser_1 = require("./concat-parser");
const default_parser_1 = require("./default-parser");
const nullish_parser_1 = require("./nullish-parser");
const function_parser_1 = require("./function-parser");
const guard_parser_1 = require("./guard-parser");
const mapped_parser_1 = require("./mapped-parser");
const maybe_parser_1 = require("./maybe-parser");
const nullable_parser_1 = require("./nullable-parser");
const named_1 = require("./named");
const nill_parser_1 = require("./nill-parser");
const number_parser_1 = require("./number-parser");
const object_parser_1 = require("./object-parser");
const or_parser_1 = require("./or-parser");
const shape_parser_1 = require("./shape-parser");
const string_parser_1 = require("./string-parser");
const utils_2 = require("./utils");
const on_mismatch_1 = require("./on-mismatch");
const unknown_parser_1 = require("./unknown-parser");
const with_retry_1 = require("./with-retry");
function unwrapParser(a) {
    if (Parser.isParser(a))
        return unwrapParser(a.parser);
    return a;
}
const enumParsed = {
    parsed(value) {
        return { value };
    },
    invalid(error) {
        return { error };
    },
};
/**
 * A Parser is usually a function that takes a value and returns a Parsed value.
 * For this class we have that as our main reason but we want to be able to have other methods
 * including testing and showing text representations.
 *
 * The main function unsafeCast which will take in a value A (usually unknown) and will always return a B. If it cannot
 * it will throw an error.
 *
 * The parse function is the lower level function that will take in a value and a dictionary of what to do with success and failure.
 */
class Parser {
    parser;
    description;
    /**
     * This is a helper to check if the parser is an IParser.
     * @param parser
     * @returns
     */
    static isIParser(parser) {
        return ((typeof parser === "object" || typeof parser === "function") &&
            parser !== null &&
            "description" in parser &&
            "parse" in parser &&
            typeof parser.description === "object" &&
            parser.description !== null &&
            typeof parser.parse === "function" &&
            "name" in parser.description &&
            "children" in parser.description &&
            "extras" in parser.description &&
            typeof parser.description.name === "string" &&
            Array.isArray(parser.description.children) &&
            Array.isArray(parser.description.extras));
    }
    /**
     * This is a helper to check if the parser is a wrapper parser.
     * @param a
     * @returns
     */
    static isParser(a) {
        if (!Parser.isIParser(a))
            return false;
        if (!("parser" in a && Parser.isIParser(a.parser)))
            return false;
        return (a.description.name === "Wrapper" &&
            a.description.children.length === 1 &&
            a.description.children[0] === a.parser);
    }
    /// This is a hack to get the type of what the parser is going to return.
    _TYPE = null;
    constructor(parser, description = {
        name: "Wrapper",
        children: [parser],
        extras: [],
    }) {
        this.parser = parser;
        this.description = description;
    }
    /**
     * Use this when you want to decide what happens on the succes and failure cases of parsing
     * @param a
     * @param onParse
     * @returns
     */
    parse = (a, onParse) => {
        return this.parser.parse(a, onParse);
    };
    /**
     * This is a constructor helper that can use a predicate tester in the form of a guard function,
     * and will return a parser that will only parse if the predicate returns true.
     * https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types
     * @param checkIsA
     * @param name
     * @returns
     */
    static isA(checkIsA, name) {
        return new Parser(new index_1.IsAParser(checkIsA, name));
    }
    /**
     * This is the line of code that could be over written if
     * One would like to have a custom error as any shape
     */
    static validatorErrorAsString = (error) => {
        const { parser, value, keys } = error;
        const keysString = !keys.length ? "" : (keys
            .map((x) => `[${x}]`)
            .reverse()
            .join(""));
        return `${keysString}${Parser.parserAsString(parser)}(${(0, utils_1.saferStringify)(value)})`;
    };
    /**
     * Trying to convert the parser into a string representation
     * @param parserComingIn
     * @returns
     */
    static parserAsString(parserComingIn) {
        const parser = unwrapParser(parserComingIn);
        const { description: { name, extras, children }, } = parser;
        if (parser instanceof shape_parser_1.ShapeParser) {
            return `${name}<{${parser.description.children
                .map((subParser, i) => `${String(parser.description.extras[i]) || "?"}:${Parser.parserAsString(subParser)}`)
                .join(",")}}>`;
        }
        if (parser instanceof or_parser_1.OrParsers) {
            const notOrs = [];
            const matchers = [
                parser.parent,
                parser.otherParser,
            ];
            while (matchers.length > 0) {
                const current = matchers.pop();
                if (!current)
                    continue;
                if (Parser.isParser(current)) {
                    matchers.push(current.parser);
                }
                else if (current instanceof or_parser_1.OrParsers) {
                    matchers.push(current.parent, current.otherParser);
                }
                else {
                    notOrs.push(current);
                }
            }
            const parentString = `${notOrs.map((x) => Parser.parserAsString(x)).join(",")}`;
            return `${name}<${parentString}>`;
        }
        if (parser instanceof guard_parser_1.GuardParser) {
            return String(extras[0] || name);
        }
        if (parser instanceof string_parser_1.StringParser ||
            parser instanceof object_parser_1.ObjectParser ||
            parser instanceof number_parser_1.NumberParser ||
            parser instanceof bool_parser_1.BoolParser ||
            parser instanceof any_parser_1.AnyParser) {
            return name.toLowerCase();
        }
        if (parser instanceof function_parser_1.FunctionParser) {
            return name;
        }
        if (parser instanceof nill_parser_1.NilParser) {
            return "null";
        }
        if (parser instanceof array_parser_1.ArrayParser) {
            return "Array<unknown>";
        }
        const specifiers = [
            ...extras.map(utils_1.saferStringify),
            ...children.map((x) => Parser.parserAsString(x)),
        ];
        const specifiersString = `<${specifiers.join(",")}>`;
        return `${name}${specifiersString}`;
    }
    /**
     * This is the most useful parser, it assumes the happy path and will throw an error if it fails.
     * @param value
     * @returns
     */
    unsafeCast = (value) => {
        const state = this.enumParsed(value);
        if ("value" in state)
            return state.value;
        const { error } = state;
        throw new TypeError(`Failed type: ${Parser.validatorErrorAsString(error)} given input ${(0, utils_1.saferStringify)(value)}`);
    };
    /**
     * This is the like the unsafe parser, it assumes the happy path and will throw and return a failed promise during failure.
     * @param value
     * @returns
     */
    castPromise = (value) => {
        const state = this.enumParsed(value);
        if ("value" in state)
            return Promise.resolve(state.value);
        const { error } = state;
        return Promise.reject(new TypeError(`Failed type: ${Parser.validatorErrorAsString(error)} given input ${(0, utils_1.saferStringify)(value)}`));
    };
    /**
     * When we want to get the error message from the input, to know what is wrong
     * @param input
     * @returns Null if there is no error
     */
    errorMessage = (input) => {
        const parsed = this.parse(input, enumParsed);
        if ("value" in parsed)
            return;
        return Parser.validatorErrorAsString(parsed.error);
    };
    /**
     * Use this that we want to do transformations after the value is valid and parsed.
     * A use case would be parsing a string, making sure it can be parsed to a number, and then convert to a number
     * @param fn
     * @param mappingName
     * @returns
     */
    map = (fn, mappingName) => {
        return new Parser(new mapped_parser_1.MappedAParser(this, fn, mappingName));
    };
    /**
     * Use this when you want to combine two parsers into one. This will make sure that both parsers will run against the same value.
     * @param otherParser
     * @returns
     */
    concat = (otherParser) => {
        return new Parser(concat_parser_1.ConcatParsers.of(this, new Parser(otherParser)));
    };
    /**
     * Use this to combine parsers into one. This will make sure that one or the other parsers will run against the value.
     * @param otherParser
     * @returns
     */
    orParser = (otherParser) => {
        return new Parser(new or_parser_1.OrParsers(this, new Parser(otherParser)));
    };
    /**
     * Use this as a guard clause, useful for escaping during the error cases.
     * https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types
     * @param value
     * @returns
     */
    test = (value) => {
        return this.parse(value, utils_2.booleanOnParse);
    };
    /**
     * When we want to make sure that we handle the null later on in a monoid fashion,
     * and this ensures we deal with the value
     * https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#optional-chaining
     */
    optional = (_name) => {
        return new Parser(new maybe_parser_1.MaybeParser(this));
    };
    /**
     * When we want to make sure that we handle the null later on in a monoid fashion,
     * and this ensures we deal with the value
     * https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#optional-chaining
     */
    nullable = (_name) => {
        return new Parser(new nullable_parser_1.NullableParser(this));
    };
    mapVoid = (defaultValue) => {
        return this.mapNullish(defaultValue).defaultTo(defaultValue);
    };
    /**
     * There are times that we would like to bring in a value that we know as null
     * and want it to go to a default value
     */
    mapNullish = (defaultValue) => {
        return new Parser(new nullish_parser_1.NullishParsed(new Parser(new nullable_parser_1.NullableParser(this)), defaultValue));
    };
    /**
     * There are times that we would like to bring in a value that we know as undefined
     * and want it to go to a default value
     */
    defaultTo = (defaultValue) => {
        return new Parser(new default_parser_1.DefaultParser(new Parser(new maybe_parser_1.MaybeParser(this)), defaultValue));
    };
    /**
     * There are times that we would like to bring in a value that we may have as invalid,
     * and in those cases during the parse we want it to fall back to a value
     */
    onMismatch = (otherValue) => {
        return new Parser(new on_mismatch_1.OnMismatch(this, () => otherValue));
    };
    /**
     * There are times that we would like to bring in a value that we may have as invalid,
     * and in those cases during the parse we want it to fall back to a value
     */
    withMismatch = (otherValue) => {
        return new Parser(new on_mismatch_1.OnMismatch(this, otherValue));
    };
    /**
     * There are times that the parse failed, and we just want to retry with a value
     */
    onRetry = (otherValue) => {
        return new Parser(new with_retry_1.WithRetry(this, () => otherValue));
    };
    /**
     * There are times that the parse failed, and we just want to retry with a value based on the input
     */
    withRetry = (otherValue) => {
        return new Parser(new with_retry_1.WithRetry(this, otherValue));
    };
    retryable = () => {
        return (this.parser instanceof maybe_parser_1.MaybeParser ||
            this.parser instanceof unknown_parser_1.UnknownParser ||
            this.parser instanceof default_parser_1.DefaultParser ||
            this.parser instanceof on_mismatch_1.OnMismatch ||
            this.parser instanceof with_retry_1.WithRetry);
    };
    /**
     * We want to test value with a test eg isEven
     */
    validate = (isValid, otherName) => {
        return new Parser(concat_parser_1.ConcatParsers.of(this, new Parser(new index_1.IsAParser(isValid, otherName))));
    };
    /**
     * We want to refine to a new type given an original type, like isEven, or casting to a more
     * specific type
     */
    refine = (refinementTest, otherName = refinementTest.name) => {
        return new Parser(concat_parser_1.ConcatParsers.of(this, new Parser(new index_1.IsAParser(refinementTest, otherName))));
    };
    /**
     * Use this when we want to give the parser a name, and we want to be able to use the name in the error messages.
     * @param nameString
     * @returns
     */
    rename = (nameString) => {
        return (0, named_1.parserName)(nameString, this);
    };
    /**
     * This is another type of parsing that will return a value that is a discriminated union of the success and failure cases.
     * https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions
     * @param value
     * @returns
     */
    enumParsed = (value) => {
        return this.parse(value, enumParsed);
    };
    /**
     * Return the unwrapped parser/ IParser
     * @returns
     */
    unwrappedParser = () => {
        let answer = this;
        while (true) {
            const next = answer.parser;
            if (Parser.isParser(next)) {
                answer = next;
            }
            else {
                return next;
            }
        }
    };
}
exports.Parser = Parser;
//# sourceMappingURL=parser.js.map