"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecursiveParser = void 0;
exports.recursive = recursive;
const parser_1 = require("./parser");
const simple_parsers_1 = require("./simple-parsers");
/**
 * This parser is used when trying to create parsers that
 * user their own definitions in their types, like interface Tree<Leaf> {
 *   [key: string]: Tree<Leaf> | Leaf;
 * }
 */
class RecursiveParser {
    recursive;
    description;
    parser;
    static create(fn) {
        const parser = new RecursiveParser(fn);
        parser.parser = fn(new parser_1.Parser(parser));
        return parser;
    }
    constructor(recursive, description = {
        name: "Recursive",
        children: [],
        extras: [recursive],
    }) {
        this.recursive = recursive;
        this.description = description;
    }
    parse(a, onParse) {
        if (!this.parser) {
            return onParse.invalid({
                value: "Recursive Invalid State",
                keys: [],
                parser: this,
            });
        }
        return this.parser.parse(a, onParse);
    }
}
exports.RecursiveParser = RecursiveParser;
/**
 * Must pass the shape that we expect since typescript as of this point
 * can't infer with recursive functions like this.
 * @param fn This should be a function that takes a parser, basically the self in a type recursion, and
 * return a parser that is the combination of the recursion.
 * @returns
 */
function recursive(fn) {
    const value = fn(simple_parsers_1.any);
    const created = RecursiveParser.create(fn);
    return new parser_1.Parser(created);
}
//# sourceMappingURL=recursive-parser.js.map