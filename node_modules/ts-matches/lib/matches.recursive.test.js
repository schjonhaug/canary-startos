"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validatorError = void 0;
const matches_1 = __importDefault(require("./matches"));
const index_1 = require("./parsers/index");
const matches_test_1 = require("./matches.test");
exports.validatorError = (0, index_1.every)((0, index_1.shape)({
    parser: matches_1.default.object,
    keys: matches_1.default.arrayOf(matches_1.default.string),
    value: index_1.any,
}));
const unFold = {
    invalid: index_1.Parser.validatorErrorAsString,
    parsed: (x) => x,
};
test("simple recursive option", () => {
    const testValue = [4];
    const validator = matches_1.default.recursive((self) => matches_1.default.some(matches_1.default.number, matches_1.default.tuple(self)));
    const parsed = validator.unsafeCast(testValue);
    expect(parsed).toEqual(testValue);
    // @ts-expect-error
    (0, matches_test_1.isType)(parsed);
    (0, matches_test_1.isType)(parsed);
});
test("simple recursive shape", () => {
    const testValue = { test: { test: "test" } };
    const validator = matches_1.default.recursive((self) => matches_1.default.shape({ test: matches_1.default.some(matches_1.default.string, self) }));
    const parsed = validator.unsafeCast(testValue);
    expect(parsed).toEqual(testValue);
    // @ts-expect-error
    (0, matches_test_1.isType)(parsed);
    (0, matches_test_1.isType)(parsed);
});
test("simple recursive shape with invalid", () => {
    const testValue = [4];
    const validator = matches_1.default.recursive((self) => matches_1.default.shape({ test: matches_1.default.some(matches_1.default.string, self) }));
    try {
        validator.unsafeCast(testValue);
    }
    catch (e) {
        (0, matches_test_1.assertSnapshot)('"[\\"test\\"]Shape<{test:Or<Recursive<>,string>}>(\\"missingProperty\\")"', validator.parse(testValue, unFold));
        return;
    }
    throw new Error("should be invalid");
});
test("simple recursive shape with invalid", () => {
    const testValue = { test: "test" };
    const validator = matches_1.default.recursive((self) => matches_1.default.shape({ test: matches_1.default.some(matches_1.default.string, self) }));
    validator.parser.parser = null;
    try {
        validator.unsafeCast(testValue);
    }
    catch (e) {
        (0, matches_test_1.assertSnapshot)('"Recursive<>(\\"Recursive Invalid State\\")"', validator.parse(testValue, unFold));
        return;
    }
    throw new Error("should be invalid");
});
//# sourceMappingURL=matches.recursive.test.js.map