"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validatorError = void 0;
exports.isType = isType;
exports.assertSnapshot = assertSnapshot;
const matches_1 = __importDefault(require("./matches"));
const index_1 = require("./parsers/index");
const utils_1 = require("./utils");
const isNumber = (x) => typeof x === "number";
class Event {
    type;
    constructor(type) {
        this.type = type;
    }
}
exports.validatorError = (0, index_1.every)((0, index_1.shape)({
    parser: matches_1.default.object,
    keys: matches_1.default.arrayOf(matches_1.default.string),
    value: index_1.any,
}));
function isType(_x) { }
function assertNeverUnknown(a) {
    return a;
}
function assertSnapshot(expected, actual) {
    expect((0, utils_1.saferStringify)(actual)).toEqual(expected);
}
const unFold = {
    invalid: index_1.Parser.validatorErrorAsString,
    parsed: (x) => x,
};
const stringFold = {
    invalid: (x) => `invalid(${(0, utils_1.saferStringify)(x)})`,
    parsed: (x) => `parsed(${(0, utils_1.saferStringify)(x)})`,
};
test("testing catches", () => {
    const testValue = { a: "c" };
    const left = { left: true };
    const right = { right: true };
    const testMatch = matches_1.default.shape({ a: matches_1.default.literal("c") });
    const validator = (0, matches_1.default)(testValue)
        .when(testMatch, () => left)
        .defaultTo(right);
    expect(validator).toEqual(left);
});
test("testing falls through", () => {
    const testValue = { a: "c" };
    const left = { left: true };
    const right = { right: true };
    const testMatch = matches_1.default.shape({ a: matches_1.default.literal("d") });
    const validator = (0, matches_1.default)(testValue)
        .when(testMatch, () => left)
        .defaultTo(right);
    expect(validator).toEqual(right);
});
test("testing catches lazy", () => {
    const testValue = { a: 0 };
    const left = { left: true };
    const right = { right: true };
    const testMatch = matches_1.default.shape({ a: matches_1.default.natural });
    const validator = (0, matches_1.default)(testValue)
        .when(testMatch, () => left)
        .defaultToLazy(() => right);
    expect(validator).toEqual(left);
});
test("testing falls through lazy", () => {
    const testValue = { a: "c" };
    const left = { left: true };
    const right = { right: true };
    const testMatch = matches_1.default.shape({ a: matches_1.default.literal("d") });
    const validator = (0, matches_1.default)(testValue)
        .when(testMatch, () => left)
        .defaultToLazy(() => right);
    expect(validator).toEqual(right);
});
test("testing can match literal", () => {
    const testValue = 5;
    const value = (0, matches_1.default)(testValue)
        .when(5, 2)
        .unwrap();
    expect(value).toEqual(2);
});
test("testing can cast literal null", () => {
    matches_1.default.literal(null).unsafeCast(null);
});
test("testing can match literal lazy", () => {
    const testValue = 5;
    const value = (0, matches_1.default)(testValue)
        .when(5, () => 2)
        .unwrap();
    expect(value).toEqual(2);
});
test("testing can match several literals", () => {
    const testValue = 5;
    const value = (0, matches_1.default)(testValue)
        .when(2, 5, () => 2)
        .unwrap();
    expect(value).toEqual(2);
});
test("unwrap when not matched will throw", () => {
    const testValue = 5;
    try {
        (0, matches_1.default)(testValue)
            .when(2, () => 2)
            // @ts-expect-error We are expecting that unwrap should not be callable
            .unwrap();
    }
    catch (_e) {
        return;
    }
    throw new Error("should have thrown");
});
test("default literal", () => {
    expect((0, matches_1.default)(5).when("5").unwrap()).toEqual("5");
});
test("default literal for object", () => {
    expect(() => (0, matches_1.default)({})
        .when(matches_1.default.shape({ testing: matches_1.default.string }), 6)
        // @ts-expect-error I'm expecting that unwrap is not guarenteed
        .unwrap()).toThrow();
});
test("testing type inferencing of matching", () => {
    (0, matches_1.default)(5)
        // @ts-expect-error Error is that 6 is not a subset 2
        .when(2, (_a) => 1)
        .defaultTo(4);
    (0, matches_1.default)(5)
        // @ts-expect-error Error is that 6 is not a subset 2
        .when(matches_1.default.literal(2), (_a) => 2);
    (0, matches_1.default)(5)
        .when(matches_1.default.literal(6), (_a) => 3)
        .when(2, 5, (a) => a)
        // @ts-expect-error Should be never since all cases are covered
        .when(2, 5, (a) => a)
        .defaultTo(0);
    (0, matches_1.default)("test")
        .when("string", "a")
        .when(matches_1.default.string, "b")
        // @ts-expect-error Should be never since all cases are covered
        .when(matches_1.default.string, "c")
        .defaultTo(0);
    (0, matches_1.default)("test")
        .when("a")
        // @ts-expect-error Should be never since all cases are covered
        .when("b")
        .defaultTo(0);
    const _answer = (0, matches_1.default)("test")
        .when("string", "a")
        .when(matches_1.default.string, () => "b")
        .unwrap();
    const _answer2 = (0, matches_1.default)("test").when("a").unwrap();
});
test("should be able to test shape", () => {
    const testValue = { a: "c" };
    const validator = matches_1.default.shape({ a: matches_1.default.literal("c") });
    expect(validator.parse(testValue, unFold)).toEqual(testValue);
});
test("should not get an error message for missing key", () => {
    const testValue = { a: "c" };
    const validator = matches_1.default.shape({ a: matches_1.default.any });
    const message = validator.errorMessage(testValue);
    expect(message).toEqual(undefined);
});
test("should fail for missing key", () => {
    const testValue = {};
    const validator = matches_1.default.shape({ a: matches_1.default.any });
    assertSnapshot('"[\\"a\\"]Shape<{a:any}>(\\"missingProperty\\")"', validator.parse(testValue, unFold));
});
test("should get an error message for missing key", () => {
    const testValue = {};
    const validator = matches_1.default.shape({ a: matches_1.default.any });
    const message = validator.errorMessage(testValue);
    assertSnapshot('"[\\"a\\"]Shape<{a:any}>(\\"missingProperty\\")"', message);
});
test("should be able to test shape with failure", () => {
    const testValue = { a: "c" };
    const validator = matches_1.default.shape({ a: matches_1.default.literal("b") });
    assertSnapshot('"[\\"a\\"]Literal<\\"b\\">(\\"c\\")"', validator.parse(testValue, unFold));
});
test("should be able to test shape with failure: not object", () => {
    const testValue = 5;
    const validator = matches_1.default.shape({ a: matches_1.default.literal("b") });
    expect(validator.parse(testValue, unFold)).toEqual(`Shape<{a:Literal<\"b\">}>(${(0, utils_1.saferStringify)(testValue)})`);
});
test("should be able to test shape with failure", () => {
    const testValue = {};
    const validator = matches_1.default.shape({
        a: matches_1.default.literal("b"),
        b: matches_1.default.literal("b"),
    });
    assertSnapshot('"[\\"a\\"]Shape<{a:Literal<\\"b\\">,b:Literal<\\"b\\">}>(\\"missingProperty\\")"', validator.parse(testValue, unFold));
});
test("should be able to test shape with failure smaller", () => {
    const testValue = { a: "b" };
    const validator = matches_1.default.shape({
        a: matches_1.default.literal("b"),
        b: matches_1.default.literal("b"),
    });
    assertSnapshot('"[\\"b\\"]Shape<{a:Literal<\\"b\\">,b:Literal<\\"b\\">}>(\\"missingProperty\\")"', validator.parse(testValue, unFold));
});
test("should be able to test partial shape", () => {
    const testValue = {};
    const validator = matches_1.default.partial({ a: matches_1.default.literal("c") });
    expect(validator.parse(testValue, unFold)).toEqual(testValue);
});
test("should be able to test partial shape failure", () => {
    const testValue = { a: "a", b: "b" };
    const validator = matches_1.default.partial({
        a: matches_1.default.literal("c"),
        b: matches_1.default.literal("c"),
    });
    assertSnapshot('"[\\"a\\"]Literal<\\"c\\">(\\"a\\")"', validator.parse(testValue, unFold));
});
test("should be able to test partial shape failure smaller", () => {
    const testValue = { b: "b" };
    const validator = matches_1.default.partial({
        a: matches_1.default.literal("c"),
        b: matches_1.default.literal("c"),
    });
    assertSnapshot('"[\\"b\\"]Literal<\\"c\\">(\\"b\\")"', validator.parse(testValue, unFold));
});
test("should recover shape mismatch", () => {
    const validator = matches_1.default.shape({
        a: matches_1.default
            .shape({
            b: matches_1.default.number.onMismatch(-1),
        })
            .withMismatch(() => ({ b: -2 })),
    });
    expect(validator.parse({}, unFold)).toEqual({ a: { b: -2 } });
    expect(validator.parse({ a: {} }, unFold)).toEqual({ a: { b: -1 } });
    expect(validator.parse({ a: { b: 5 } }, unFold)).toEqual({ a: { b: 5 } });
});
test("should recover shape retry", () => {
    const validator = matches_1.default.shape({
        a: matches_1.default
            .shape({
            b: matches_1.default.number.onRetry(-1),
        })
            .withRetry(() => ({ b: -2 })),
    });
    expect(validator.parse({}, unFold)).toEqual({ a: { b: -2 } });
    expect(validator.parse({ a: {} }, unFold)).toEqual({ a: { b: -1 } });
    expect(validator.parse({ a: { b: 5 } }, unFold)).toEqual({ a: { b: 5 } });
});
test("should recover shape retry bad", () => {
    const validator = matches_1.default.shape({
        a: matches_1.default
            .shape({
            b: matches_1.default.number.onRetry("-1"),
        })
            .withRetry(() => "{ b: -2 }"),
    });
    expect(validator.parse({}, unFold)).toEqual('[TypeError: Failed type: Partial<{b:WithRetry<,number>}>(undefined) given input undefined]Mapped<"",Partial<{a:WithRetry<,Mapped<"",Partial<{b:WithRetry<,number>}>>>}>>({})');
    expect(validator.parse({ a: {} }, unFold)).toEqual('["a"][TypeError: Failed type: number(undefined) given input undefined]Mapped<"",Partial<{b:WithRetry<,number>}>>({})');
    expect(validator.parse({ a: { b: 5 } }, unFold)).toEqual({ a: { b: 5 } });
});
{
    const validator = matches_1.default.shape({
        a: matches_1.default.literal("c"),
        b: matches_1.default.literal("d").optional(),
    });
    isType(validator);
    // @ts-expect-error Not type
    isType(validator);
    test("should be able to test shape with partial not included", () => {
        const testValue = { a: "c" };
        const value = validator.unsafeCast(testValue);
        expect(value).toEqual(testValue);
        expect(value.b).toEqual(undefined);
        isType(value);
        // @ts-expect-error Is not a number
        isType(value);
    });
    test("should be able to test shape with partial correct", () => {
        const testValue = { a: "c", b: "d" };
        const value = validator.unsafeCast(testValue);
        expect(value).toEqual(testValue);
        isType(value);
        // @ts-expect-error Is not a number
        isType(value);
    });
    test("should be able to test shape with partial and main not included", () => {
        const testValue = { b: "d" };
        try {
            validator.unsafeCast(testValue);
        }
        catch (_e) {
            assertSnapshot('"[\\"a\\"]Shape<{a:Literal<\\"c\\">}>(\\"missingProperty\\")"', validator.parse(testValue, unFold));
            return;
        }
        throw new Error("should be invalid");
    });
    test("should be able to test shape with value `b` as null", () => {
        const testValue = { b: null, a: "c" };
        expect(validator.parse(testValue, unFold)).toEqual('["b"]Maybe<Literal<"d">>(null)');
    });
    test("should be able to test shape with value `b` as undefined", () => {
        const testValue = { b: undefined, a: "c" };
        expect(validator.parse(testValue, unFold)).toEqual({
            a: "c",
            b: undefined,
        });
    });
    test("should be able to test shape with partial is wrong", () => {
        const testValue = { a: "c", b: "e" };
        try {
            validator.unsafeCast(testValue);
        }
        catch (_e) {
            assertSnapshot('"[\\"b\\"]Maybe<Literal<\\"d\\">>(\\"e\\")"', validator.parse(testValue, unFold));
            return;
        }
        throw new Error("should be invalid");
    });
    test("should be able to shape with partials and fill in defaults", () => {
        const validator = matches_1.default.shape({
            a: matches_1.default.literal("c"),
            b: matches_1.default.literal("d").defaultTo("d"),
            f: matches_1.default.literal("f").optional(),
        });
        isType(validator);
        isType(validator);
        const testValue = { a: "c" };
        const value = validator.unsafeCast(testValue);
        expect(value).toEqual({ a: "c", b: "d" });
        expect(value.b).toEqual("d");
        isType(value);
        // @ts-expect-error Value should not be type
        isType(value);
    });
    test("should be able to shape with nullable and fill in defaults", () => {
        const validator = matches_1.default.shape({
            a: matches_1.default.literal("c"),
            b: matches_1.default.literal("d").defaultTo("d"),
            f: matches_1.default.literal("f").nullable(),
        });
        isType(validator);
        const testValue = { a: "c" };
        const value = validator.parse(testValue, unFold);
        expect(value).toEqual('["f"]Shape<{a:Literal<"c">,f:Nullable<Literal<"f">>}>("missingProperty")');
        const testValueCorrect = { a: "c", f: null };
        const value2 = validator.unsafeCast(testValueCorrect);
        expect(value2).toEqual({
            a: "c",
            f: null,
            b: "d",
        });
        isType(value2);
        // @ts-expect-error Value should not be type
        isType(value2);
    });
}
test("should be able to test literal", () => {
    const testValue = "a";
    const validator = matches_1.default.literal("a");
    expect(validator.parse(testValue, unFold)).toEqual(testValue);
});
test("should be able to test array literal", () => {
    const testValue = ["a", "b"];
    const validator = matches_1.default.literal(["a", "b"]);
    expect(validator.parse(testValue, unFold)).toEqual(testValue);
});
test("should be able to test object literal", () => {
    const testValue = { a: "a", b: ["c", "d"] };
    const validator = matches_1.default.literal({ a: "a", b: ["c", "d"] });
    expect(validator.parse(testValue, unFold)).toEqual(testValue);
});
test("should be able to test literal with failure", () => {
    const testValue = "a";
    const validator = matches_1.default.literal("b");
    assertSnapshot('"Literal<\\"b\\">(\\"a\\")"', validator.parse(testValue, unFold));
});
test("should be able to test unknown", () => {
    const testValue = 4;
    const validator = matches_1.default.unknown;
    expect(validator.parse(testValue, unFold)).toEqual(testValue);
});
test("should be able to test nill invalid", () => {
    const testValue = 4;
    const validator = matches_1.default.nill;
    expect(validator.parse(testValue, unFold)).toEqual("null(4)");
});
test("should be able to test nill valid", () => {
    const testValue = null;
    const validator = matches_1.default.nill;
    expect(validator.parse(testValue, unFold)).toEqual(testValue);
});
test("should be able to test array valid", () => {
    const testValue = ["test"];
    const validator = matches_1.default.array;
    expect(validator.parse(testValue, unFold)).toEqual(testValue);
});
test("should be able to test array invalid", () => {
    const testValue = "test";
    const validator = matches_1.default.array;
    expect(validator.parse(testValue, unFold)).toEqual('Array<unknown>("test")');
});
test("should be able to test number", () => {
    const testValue = 4;
    const validator = matches_1.default.number;
    expect(validator.parse(testValue, unFold)).toEqual(testValue);
});
test("should be able to test number with failure", () => {
    const testValue = "a";
    const validator = matches_1.default.number;
    assertSnapshot('"number(\\"a\\")"', validator.parse(testValue, unFold));
});
test("should be able to test string", () => {
    const testValue = "a";
    const validator = matches_1.default.string;
    expect(validator.parse(testValue, unFold)).toEqual(testValue);
});
test("should be able to test string with failure", () => {
    const testValue = 5;
    const validator = matches_1.default.string;
    assertSnapshot('"string(5)"', validator.parse(testValue, unFold));
});
test("should be able to test regex", () => {
    const testValue = "test";
    const validator = matches_1.default.regex(/test/);
    expect(validator.parse(testValue, unFold)).toEqual(testValue);
});
test("should be able to test regex with failure", () => {
    const testValue = "Invalid";
    const validator = matches_1.default.regex(/test/);
    assertSnapshot('"/test/(\\"Invalid\\")"', validator.parse(testValue, unFold));
});
test("should be able to test isFunction", () => {
    const testValue = () => ({});
    const validator = matches_1.default.isFunction;
    expect(validator.parse(testValue, unFold)).toEqual(testValue);
});
test("should be able to test isFunction with failure", () => {
    const testValue = "test";
    const validator = matches_1.default.isFunction;
    assertSnapshot('"Function(\\"test\\")"', validator.parse(testValue, unFold));
});
test("should be able to test boolean", () => {
    const testValue = true;
    const validator = matches_1.default.boolean;
    expect(validator.parse(testValue, unFold)).toEqual(testValue);
});
test("should be able to test boolean false", () => {
    const testValue = false;
    const validator = matches_1.default.boolean;
    expect(validator.parse(testValue, unFold)).toEqual(testValue);
});
test("should be able to test boolean with failure", () => {
    const testValue = 0;
    const validator = matches_1.default.boolean;
    assertSnapshot('"boolean(0)"', validator.parse(testValue, unFold));
});
test("should be able to test boolean falsy with failure", () => {
    const testValue = "test";
    const validator = matches_1.default.boolean;
    assertSnapshot('"boolean(\\"test\\")"', validator.parse(testValue, unFold));
});
test("should be able to test any", () => {
    const testValue = 0;
    const validator = matches_1.default.any;
    expect(validator.parse(testValue, unFold)).toEqual(testValue);
});
test("should be able to test object", () => {
    const testValue = {};
    const validator = matches_1.default.object;
    expect(validator.parse(testValue, unFold)).toEqual(testValue);
});
test("should be able to test object with failure", () => {
    const testValue = 5;
    const validator = matches_1.default.object;
    expect(validator.parse(testValue, unFold)).toEqual("object(5)");
});
test("should be able to test tuple(number, string)", () => {
    const testValue = [4, "test"];
    const validator = matches_1.default.tuple(matches_1.default.number, matches_1.default.string);
    // @ts-expect-error Invalid tuple, inverted
    const _badOutput = validator.unsafeCast(testValue);
    // @ts-expect-error Type '[number, string]' is not assignable to type '[]'.\n  Source has 2 element(s) but target allows only 0.
    const _badOutput2 = validator.unsafeCast(testValue);
    const _goodOutput = validator.unsafeCast(testValue);
    const output = validator.parse(testValue, unFold);
    expect(output).toEqual(testValue);
});
test("should be able to test tuple(number, string) with failure", () => {
    const testValue = ["bad", 5];
    const validator = matches_1.default.tuple(matches_1.default.number, matches_1.default.string);
    assertSnapshot('"[\\"0\\"]number(\\"bad\\")"', validator.parse(testValue, unFold));
});
test("should be able to use matches.when", () => {
    const testValue = 4;
    const validator = matches_1.default.number;
    expect((0, matches_1.default)(testValue)
        .when(validator, () => true)
        .defaultTo(false)).toEqual(true);
});
test("should be able to use matches.when fallback for the default to", () => {
    const testValue = "5";
    const validator = matches_1.default.number;
    expect((0, matches_1.default)(testValue)
        .when(validator, () => true)
        .defaultTo(false)).toEqual(false);
});
test("should union several matchers", () => {
    const testValue = 4;
    const validator = matches_1.default.some(matches_1.default.number, matches_1.default.string);
    expect(validator.parse(testValue, unFold)).toEqual(testValue);
});
test("should be fallible union several matchers", () => {
    const testValue = false;
    const validator = matches_1.default.some(matches_1.default.number, matches_1.default.string);
    assertSnapshot('"Or<string,number>(false)"', validator.parse(testValue, unFold));
});
test("should intersection several matchers", () => {
    const testValue = 4;
    const isEven = matches_1.default.guard((x) => isNumber(x) && x % 2 === 0, "isEven");
    const validator = matches_1.default.every(matches_1.default.number, isEven);
    expect(validator.parse(testValue, unFold)).toEqual(testValue);
});
test("every should clean up anys", () => {
    const every = matches_1.default.every(matches_1.default.any, matches_1.default.any);
    expect(every).toEqual(matches_1.default.any);
});
test("should be remove any in chains", () => {
    const testValue = 5;
    const validator = matches_1.default.any.concat(matches_1.default.string).concat(matches_1.default.any);
    assertSnapshot('"string(5)"', validator.parse(testValue, unFold));
});
test("should be remove any in chains", () => {
    const testValue = 5;
    const validator = matches_1.default.any.concat(matches_1.default.string).concat(matches_1.default.any);
    assertSnapshot('"string(5)"', validator.parse(testValue, unFold));
});
test("should be fallible union several matchers", () => {
    const testValue = 5;
    const isEven = matches_1.default.guard((x) => isNumber(x) && x % 2 === 0, "isEven");
    const isGt6 = matches_1.default.guard((x) => isNumber(x) && x > 6, "isGt6");
    const validator = matches_1.default.every(matches_1.default.number, isEven, isGt6);
    assertSnapshot('"isEven(5)"', validator.parse(testValue, unFold));
});
test("should have array of test", () => {
    const testValue = [5, 5, 5];
    const arrayOf = matches_1.default.arrayOf(matches_1.default.literal(5));
    expect(arrayOf.parse(testValue, unFold)).toEqual(testValue);
});
test("should have array of test negative", () => {
    const testValue = "bad";
    const arrayOf = matches_1.default.arrayOf(matches_1.default.literal(5));
    assertSnapshot('"ArrayOf<Literal<5>>(\\"bad\\")"', arrayOf.parse(testValue, unFold));
});
test("should be able to get the value of an array of", () => {
    const testValue = [{ test: 5 }];
    const matchTest = matches_1.default.shape({ test: matches_1.default.number });
    const arrayOf = matches_1.default.arrayOf(matchTest);
    const _testValue = assertNeverUnknown(arrayOf.unsafeCast(testValue)[0]);
    const testValuesGood = arrayOf.unsafeCast(testValue)[0];
    expect(testValuesGood).toEqual(testValue[0]);
});
test("should be able to get the value of an array of using (object, array) instead of (shape, arrayOf)", () => {
    const testValue = [{ test: 5 }];
    const matchTest = matches_1.default.object({ test: matches_1.default.number });
    const arrayOf = matches_1.default.array(matchTest);
    const _testValue = assertNeverUnknown(arrayOf.unsafeCast(testValue)[0]);
    const testValuesGood = arrayOf.unsafeCast(testValue)[0];
    expect(testValuesGood).toEqual(testValue[0]);
});
test("should be able to match literals", () => {
    const matcher = matches_1.default.literals(4, "3");
    const firstExpectedOutcome = matcher.parse(4, unFold);
    expect(firstExpectedOutcome).toEqual(4);
    expect(matcher.parse("3", unFold)).toEqual("3");
    assertSnapshot('"Literal<4,\\"3\\">(3)"', matcher.parse(3, unFold));
    assertSnapshot('"Literal<4,\\"3\\">(\\"4\\")"', matcher.parse("4", unFold));
});
test("should have array of test fail", () => {
    const testValue = [5, 3, 2, 5, 5];
    const arrayOf = matches_1.default.arrayOf(matches_1.default.literal(5));
    assertSnapshot('"[1]Literal<5>(3)"', arrayOf.parse(testValue, unFold));
});
test("should refinement matchers", () => {
    const testValue = 4;
    const isEven = matches_1.default.number.refine((num) => {
        // Make sure that the refine types pass down the number
        const _test = num;
        // Asserting to typescript that the infered type not something else
        // @ts-expect-error Type mismatch
        const _test2 = num;
        return num % 2 === 0;
    }, "isEven");
    expect(isEven.parse(testValue, unFold)).toEqual(testValue);
});
test("should valid matchers", () => {
    const testValue = 4;
    const isEven = matches_1.default.number.validate((num) => {
        // Make sure that the refine types pass down the number
        const _test = num;
        // Asserting to typescript that the infered type not something else
        // @ts-expect-error Type mismatch
        const _test2 = num;
        return num % 2 === 0;
    }, "isEven");
    expect(isEven.parse(testValue, unFold)).toEqual(testValue);
});
test("should refinement matchers fail", () => {
    const testValue = 4;
    const isEven = matches_1.default.number.refine((num) => num % 2 === 0, "isEven");
    assertSnapshot('"parsed(4)"', isEven.parse(testValue, stringFold));
});
test("should refinement matchers fail", () => {
    const testValue = 5;
    const isEven = matches_1.default.number.refine((num) => num % 2 === 0, "isEven");
    assertSnapshot('"isEven(5)"', isEven.parse(testValue, unFold));
});
test("should refinement matchers fail cleanup any", () => {
    const testValue = 5;
    const isEven = matches_1.default.any.refine((num) => num % 2 === 0, "isEven");
    try {
        isEven.unsafeCast(testValue);
    }
    catch (e) {
        assertSnapshot('"Failed type: isEven(5) given input 5"', e.message);
    }
});
test("should throw on invalid unsafe match throw", () => {
    try {
        matches_1.default.partial({}).unsafeCast(5);
    }
    catch (e) {
        assertSnapshot('"Failed type: Partial<{}>(5) given input 5"', e.message);
    }
});
test("should throw on invalid unsafe match throw", async () => {
    try {
        await matches_1.default.partial({}).castPromise(5);
        expect("never").toBe("called");
    }
    catch (e) {
        assertSnapshot(`{}`, e);
    }
});
test("should throw on invalid unsafe match throw", async () => {
    expect(await matches_1.default.literal(5).castPromise(5)).toBe(5);
});
test("some should be any if empty", () => {
    expect(matches_1.default.some()).toEqual(matches_1.default.any);
});
test("some should only return the unique", () => {
    assertSnapshot('"Or<number,Literal<\\"test\\">,number>(\\"hello\\")"', matches_1.default
        .some(matches_1.default.number, matches_1.default.literal("test"), matches_1.default.number)
        .parse("hello", unFold));
});
test("some should only return the unique", () => {
    assertSnapshot('"Or<number,number>(\\"hello\\")"', matches_1.default.some(matches_1.default.number, matches_1.default.number).parse("hello", unFold));
});
test("should guard without a name", () => {
    expect(matches_1.default.guard((x) => Number(x) > 3).unsafeCast(6)).toBe(6);
});
test("should guard without a name failure", () => {
    assertSnapshot('"invalid({\\"value\\":2,\\"keys\\":[],\\"parser\\":{\\"typeName\\":\\"\\",\\"description\\":{\\"name\\":\\"Guard\\",\\"children\\":[],\\"extras\\":[\\"\\"]}}})"', matches_1.default.guard((x) => Number(x) > 3).parse(2, stringFold));
});
test("should be able to test is object for event", () => {
    const event = new Event("test");
    expect(matches_1.default.object.parse(event, unFold)).toBe(event);
});
{
    class Fake {
        value;
        constructor(value) {
            this.value = value;
        }
    }
    test("testing is instance: should be able to validate it is a instance", () => {
        const value = new Fake(3);
        expect(matches_1.default.instanceOf(Fake).test(value)).toEqual(true);
        expect(matches_1.default.instanceOf(Fake).parse(value, unFold)).toEqual(value);
    });
    test("testing is instance: should be able to validate it is not a instance", () => {
        const value = {
            value: 4,
        };
        expect(matches_1.default.instanceOf(Fake).test(value)).toEqual(false);
        assertSnapshot('"isFake({\\"value\\":4})"', matches_1.default.instanceOf(Fake).parse(value, unFold));
    });
}
test("should fail on a circular object", () => {
    const o = {};
    o.o = o;
    assertSnapshot('"Function([object Object])"', matches_1.default.isFunction.parse(o, unFold));
});
test("should be able to map validation", () => {
    const testString = "test";
    const event = new Event(testString);
    const isEvent = matches_1.default.guard((x) => x instanceof Event, "isEvent");
    expect(isEvent
        .map((x) => {
        // Asserting to typescript that the infered type is event
        const _test = x;
        // @ts-expect-error Asserting to typescript that the infered type not something else
        const _test2 = x;
        return x.type;
    })
        .parse(event, unFold)).toBe(testString);
});
test("should be able to map validation with name", () => {
    const testString = "test";
    const event = new Event(testString);
    const isEvent = matches_1.default.guard((x) => x instanceof Event, "isEvent");
    expect(isEvent
        .map(function asType(x) {
        return x.type;
    })
        .parse(event, unFold)).toBe(testString);
});
{
    const maybeNumber = matches_1.default.number.optional();
    test("with a number.maybe matcher: a number in", () => {
        const input = 4;
        const expectedAnswer = 4;
        expect(maybeNumber.parse(input, unFold)).toBe(expectedAnswer);
    });
    test("with a number.maybe matcher: a null in", () => {
        const input = null;
        expect(maybeNumber.parse(input, unFold)).toBe("Maybe<number>(null)");
    });
    test("with a number.maybe matcher: a undefined in", () => {
        const input = undefined;
        expect(maybeNumber.parse(input, unFold)).toBe(undefined);
    });
    test("with a number.maybe matcher: a object in", () => {
        const input = {};
        assertSnapshot('"\\"Maybe<number>({})\\""', (0, utils_1.saferStringify)(maybeNumber.parse(input, unFold)));
    });
}
{
    const nullableNumber = matches_1.default.number.nullable();
    test("with a number.nullable matcher: a number in", () => {
        const input = 4;
        const expectedAnswer = 4;
        expect(nullableNumber.parse(input, unFold)).toBe(expectedAnswer);
    });
    test("with a number.nullable matcher: a null in", () => {
        const input = null;
        expect(nullableNumber.parse(input, unFold)).toBe(null);
    });
    test("with a number.nullable matcher: a undefined in", () => {
        const input = undefined;
        assertSnapshot('"Nullable<number>(undefined)"', nullableNumber.parse(input, unFold));
    });
    test("with a number.nullable matcher: a object in", () => {
        const input = {};
        assertSnapshot('"\\"Nullable<number>({})\\""', (0, utils_1.saferStringify)(nullableNumber.parse(input, unFold)));
    });
}
{
    const maybeNumber = matches_1.default.number.defaultTo(0);
    test("with a number.defaultTo matcher: a number in", () => {
        const input = 4;
        const expected = 4;
        expect(maybeNumber.parse(input, unFold)).toBe(expected);
    });
    test("with a number.defaultTo matcher: a null in", () => {
        const input = null;
        const expected = "Default<0,Maybe<number>>(null)";
        expect(maybeNumber.parse(input, unFold)).toBe(expected);
    });
    test("with a number.defaultTo matcher: a undefined in", () => {
        const input = undefined;
        const expected = 0;
        expect(maybeNumber.parse(input, unFold)).toBe(expected);
    });
    test("with a number.defaultTo matcher: a object in", () => {
        const input = {};
        assertSnapshot('"Default<0,Maybe<number>>({})"', maybeNumber.parse(input, unFold));
    });
}
{
    const retryNumber = matches_1.default.number.withRetry((a) => index_1.string.test(a) ? Number.parseFloat(a) : a);
    test("with a number.withRetry matcher: a number in", () => {
        const input = 4;
        const expected = 4;
        expect(retryNumber.parse(input, unFold)).toBe(expected);
    });
    test("with a number.withRetry matcher: a string number in", () => {
        const input = "7";
        const expected = 7;
        expect(retryNumber.parse(input, unFold)).toBe(expected);
    });
    test("with a number.withRetry matcher: a null in", () => {
        const input = null;
        const expected = "number(null)";
        expect(retryNumber.parse(input, unFold)).toBe(expected);
    });
    test("with a number.withRetry matcher: a undefined in", () => {
        const input = undefined;
        const expected = "number(undefined)";
        expect(retryNumber.parse(input, unFold)).toBe(expected);
    });
    test("with a number.withRetry matcher: a object in", () => {
        const input = {};
        assertSnapshot('"number({})"', retryNumber.parse(input, unFold));
    });
}
{
    const maybeNumber = matches_1.default.number.mapNullish(0);
    test("with a number.mapNullish matcher: a number in", () => {
        const input = 4;
        const expected = 4;
        expect(maybeNumber.parse(input, unFold)).toBe(expected);
    });
    test("with a number.mapNullish matcher: a null in", () => {
        const input = null;
        const expected = 0;
        expect(maybeNumber.parse(input, unFold)).toBe(expected);
    });
    test("with a number.mapNullish matcher: a undefined in", () => {
        const input = undefined;
        const expected = "Nullable<0,Nullable<number>>(undefined)";
        expect(maybeNumber.parse(input, unFold)).toBe(expected);
    });
    test("with a number.mapNullish matcher: a object in", () => {
        const input = {};
        assertSnapshot('"Nullable<0,Nullable<number>>({})"', maybeNumber.parse(input, unFold));
    });
}
{
    const maybeNumber = matches_1.default.number.onMismatch(0);
    test("with a number.onMismatch matcher a number in", () => {
        const input = 4;
        const expected = 4;
        expect(maybeNumber.parse(input, unFold)).toBe(expected);
    });
    test("with a number.onMismatch matcher a null in", () => {
        const input = null;
        const expected = 0;
        expect(maybeNumber.parse(input, unFold)).toBe(expected);
    });
    test("with a number.onMismatch matcher a undefined in", () => {
        const input = undefined;
        const expected = 0;
        expect(maybeNumber.parse(input, unFold)).toBe(expected);
    });
    test("with a number.onMismatch matcher a object in", () => {
        const input = {};
        expect(maybeNumber.parse(input, unFold)).toMatchInlineSnapshot(`0`);
    });
    test("with a number.onMismatch matcher a string in", () => {
        const input = "4";
        expect(maybeNumber.parse(input, unFold)).toMatchInlineSnapshot(`0`);
    });
}
{
    const maybeNumber = matches_1.default.number.withMismatch(() => 5);
    test("with a number.withMismatch matcher a number in", () => {
        const input = 4;
        const expected = 4;
        expect(maybeNumber.parse(input, unFold)).toBe(expected);
    });
    test("with a number.withMismatch matcher a null in", () => {
        const input = null;
        const expected = 5;
        expect(maybeNumber.parse(input, unFold)).toBe(expected);
    });
    test("with a number.withMismatch matcher a undefined in", () => {
        const input = undefined;
        const expected = 5;
        expect(maybeNumber.parse(input, unFold)).toBe(expected);
    });
    test("with a number.withMismatch matcher a object in", () => {
        const input = {};
        expect(maybeNumber.parse(input, unFold)).toMatchInlineSnapshot(`5`);
    });
    test("with a number.withMismatch matcher a string in", () => {
        const input = "4";
        expect(maybeNumber.parse(input, unFold)).toMatchInlineSnapshot(`5`);
    });
}
{
    test("Testing as a filter: should be able to utilize the test in a filter for typing", () => {
        expect([0, "hi", 5, {}].filter(matches_1.default.number.test)).toEqual([0, 5]);
    });
}
{
    const enumTest = matches_1.default.literals("A", "B").rename("enumTest");
    test("Testing named: should be able to test valid should be the same", () => {
        const input = "A";
        // @ts-expect-error A is not b
        const _output = enumTest.unsafeCast(input);
        const _correctType = enumTest.unsafeCast(input);
    });
    test("Testing named: should be able to test invalid with wrapped name", () => {
        const input = "bad";
        const output = enumTest.parse(input, unFold);
        assertSnapshot(`"Named<\\"enumTest\\",Literal<\\"A\\",\\"B\\">>(\\"bad\\")"`, output);
    });
}
{
    const testMatcher = matches_1.default.dictionary([matches_1.default.literal("test"), matches_1.default.literal("value")], [matches_1.default.literal("test2"), matches_1.default.literal("value2")]);
    test("Testing dictionaries: should be able to check correct shape", () => {
        const input = { test: "value", test2: "value2" };
        const output = testMatcher.unsafeCast(input);
        expect(output).toEqual(input);
        //@ts-expect-error Wrong shape in test
        const _incorrectCast = testMatcher.unsafeCast(input);
        const _correctCast = testMatcher.unsafeCast(input);
    });
    test("Testing dictionaries: should be able to check incorrect shape", () => {
        const input = { test: "invalid", test2: "value2" };
        const output = testMatcher.parse(input, unFold);
        assertSnapshot(`"[test]Literal<\\"value\\">(\\"invalid\\")"`, output);
    });
    test("Testing dictionaries: should be able to check empty", () => {
        const testMatcher = matches_1.default.dictionary();
        const input = { test: "invalid", test2: "value2" };
        const output = testMatcher.parse(input, unFold);
        assertSnapshot(`{"test":"invalid","test2":"value2"}`, output);
    });
    test("Testing dictionaries: should be able to check incorrect shape deep", () => {
        const input = [
            {
                second: "invalid",
            },
        ];
        const output = matches_1.default
            .tuple(matches_1.default.shape({
            second: matches_1.default.literal("valid"),
        }))
            .parse(input, unFold);
        assertSnapshot(`"[\\"0\\"][\\"second\\"]Literal<\\"valid\\">(\\"invalid\\")"`, output);
    });
    test("Testing dictionaries: should be able to check tuple exact shape", () => {
        const input = [1, 2, 3];
        const matcher = matches_1.default.tuple(matches_1.default.number, matches_1.default.literal(2), matches_1.default.number);
        // @ts-expect-error Wrong shape
        const outputWrong = matcher.unsafeCast(input);
        // @ts-expect-error Wrong shape
        const _outputWrong2 = matcher.unsafeCast(input);
        // @ts-expect-error Wrong shape
        const _outputWrong3 = matcher.unsafeCast(input);
        const outputRight1 = matcher.unsafeCast(input);
        const _outputRight2 = matcher.unsafeCast(input);
        // expected type: Validator<unknown, [number,number,number]>
        // actual type: Validator<unknown, never>;
        expect(outputRight1).toEqual(input);
        expect(outputWrong).toEqual(input);
    });
    test("Testing dictionaries: should be able to project values", () => {
        const input = { test: "value" };
        const matcher = matches_1.default.dictionary([
            matches_1.default.literal("test"),
            matches_1.default.literal("value").map((_x) => `value2`),
        ]);
        // @ts-expect-error Test missing
        const _outputWrong = matcher.unsafeCast(input);
        const _outputOk = matcher.unsafeCast(input);
        const outputMostCorrect = matcher.unsafeCast(input);
        expect(outputMostCorrect.test).toEqual("value2");
    });
    test("Testing dictionaries: should be able to still reject values", () => {
        const input = { test: "value2" };
        const matcher = matches_1.default.dictionary([
            matches_1.default.literal("test"),
            matches_1.default.literal("value").map((_x) => `value2`),
        ]);
        const output = matcher.parse(input, unFold);
        assertSnapshot(`"[test]Literal<\\"value\\">(\\"value2\\")"`, output);
    });
    test("Testing dictionaries: should be able to project keys", () => {
        const input = { test: "value" };
        const matcher = matches_1.default.dictionary([
            matches_1.default.literal("test").map((_x) => "projected"),
            matches_1.default.literal("value"),
        ]);
        // @ts-expect-error Property 'test' is missing in type
        const _incorrectOutput = matcher.unsafeCast(input);
        const output = matcher.unsafeCast(input);
        expect(output.projected).toEqual("value");
    });
}
{
    test("Issue where dictionary reordered", () => {
        const dataIn = {
            A: 1,
            B: 1,
            C: 1,
        };
        const expectedKeys = JSON.stringify(Object.keys(dataIn));
        const newShape = (0, matches_1.default)(dataIn)
            .when(matches_1.default.dictionary([matches_1.default.string, matches_1.default.unknown]), (x) => x)
            .defaultToLazy(() => {
            throw new Error("Should match");
        });
        const actualKeys = JSON.stringify(Object.keys(newShape));
        expect(actualKeys).toEqual(expectedKeys);
    });
}
//# sourceMappingURL=matches.test.js.map