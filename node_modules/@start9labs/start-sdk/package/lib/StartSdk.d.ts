import { Value } from "../../base/lib/actions/input/builder/value";
import { InputSpec } from "../../base/lib/actions/input/builder/inputSpec";
import { Variants } from "../../base/lib/actions/input/builder/variants";
import { Action, ActionInfo, Actions } from "../../base/lib/actions/setupActions";
import { ServiceInterfaceId, PackageId, ServiceInterfaceType, Effects } from "../../base/lib/types";
import * as patterns from "../../base/lib/util/patterns";
import { BackupSync, Backups } from "./backup/Backups";
import { Daemon, Daemons } from "./mainFn/Daemons";
import { checkPortListening } from "./health/checkFns/checkPortListening";
import { List } from "../../base/lib/actions/input/builder/list";
import { SetupBackupsParams } from "./backup/setupBackups";
import { changeOnFirstSuccess, cooldownTrigger } from "./trigger";
import { MultiHost, Scheme } from "../../base/lib/interfaces/Host";
import { ServiceInterfaceBuilder } from "../../base/lib/interfaces/ServiceInterfaceBuilder";
import { GetSystemSmtp } from "./util";
import { nullIfEmpty } from "./util";
import { CommandOptions, SubContainer } from "./util/SubContainer";
import { Mounts } from "./mainFn/Mounts";
import * as T from "../../base/lib/types";
import { CheckDependencies } from "../../base/lib/dependencies/dependencies";
import { GetSslCertificate } from "./util";
import { getDataVersion, setDataVersion } from "./version";
import { MaybeFn } from "../../base/lib/actions/setupActions";
import { Run } from "../../base/lib/actions/setupActions";
import * as actions from "../../base/lib/actions";
import { setupInit, setupUninit, setupOnInit, setupOnUninit } from "../../base/lib/inits";
import { DropGenerator } from "../../base/lib/util/Drop";
export declare const OSVersion: "0.4.0-alpha.14";
type AnyNeverCond<T extends any[], Then, Else> = T extends [] ? Else : T extends [never, ...Array<any>] ? Then : T extends [any, ...infer U] ? AnyNeverCond<U, Then, Else> : never;
export declare class StartSdk<Manifest extends T.SDKManifest> {
    readonly manifest: Manifest;
    private constructor();
    static of(): StartSdk<never>;
    withManifest<Manifest extends T.SDKManifest = never>(manifest: Manifest): StartSdk<Manifest>;
    build(isReady: AnyNeverCond<[Manifest], "Build not ready", true>): {
        setDataVersion: typeof setDataVersion;
        getDataVersion: typeof getDataVersion;
        action: {
            run: <Input extends Record<string, unknown>>(options: {
                effects: T.Effects;
                actionId: T.ActionId;
                input?: actions.RunActionInput<Input>;
            }) => Promise<T.ActionResult | null>;
            createTask: <T extends ActionInfo<T.ActionId, any>>(effects: T.Effects, packageId: T.PackageId, action: T, severity: T.TaskSeverity, options?: actions.TaskOptions<T>) => Promise<null>;
            createOwnTask: <T extends ActionInfo<T.ActionId, any>>(effects: T.Effects, action: T, severity: T.TaskSeverity, options?: actions.TaskOptions<T>) => Promise<null>;
            clearTask: (effects: T.Effects, ...replayIds: string[]) => Promise<null>;
        };
        checkDependencies: <DependencyId extends keyof Manifest["dependencies"] & PackageId = keyof Manifest["dependencies"] & PackageId>(effects: Effects, packageIds?: DependencyId[]) => Promise<CheckDependencies<DependencyId>>;
        serviceInterface: {
            getOwn: <E extends Effects>(effects: E, id: ServiceInterfaceId) => import("./util").GetServiceInterface;
            get: <E extends Effects>(effects: E, opts: {
                id: ServiceInterfaceId;
                packageId: PackageId;
            }) => import("./util").GetServiceInterface;
            getAllOwn: <E extends Effects>(effects: E) => import("../../base/lib/util/getServiceInterfaces").GetServiceInterfaces;
            getAll: <E extends Effects>(effects: E, opts: {
                packageId: PackageId;
            }) => import("../../base/lib/util/getServiceInterfaces").GetServiceInterfaces;
        };
        getContainerIp: (effects: T.Effects, options?: Omit<Parameters<T.Effects["getContainerIp"]>[0], "callback">) => {
            const: () => Promise<string>;
            once: () => Promise<string>;
            watch: (abort?: AbortSignal) => DropGenerator<string, void, unknown>;
            onChange: (callback: (value: string | null, error?: Error) => {
                cancel: boolean;
            } | Promise<{
                cancel: boolean;
            }>) => void;
            waitFor: (pred: (value: string | null) => boolean) => Promise<string | null>;
        };
        MultiHost: {
            of: (effects: Effects, id: string) => MultiHost;
        };
        nullIfEmpty: typeof nullIfEmpty;
        useEntrypoint: (overrideCmd?: string[]) => T.UseEntrypoint;
        /**
         * @description Use this class to create an Action. By convention, each Action should receive its own file.
         *
         */
        Action: {
            /**
             * @description Use this function to create an action that accepts form input
             * @param id - a unique ID for this action
             * @param metadata - information describing the action and its availability
             * @param inputSpec - define the form input using the InputSpec and Value classes
             * @param prefillFn - optionally fetch data from the file system to pre-fill the input form. Must returns a deep partial of the input spec
             * @param executionFn - execute the action. Optionally return data for the user to view. Must be in the structure of an ActionResult, version "1"
             * @example
             * In this example, we create an action for a user to provide their name.
             *   We prefill the input form with their existing name from the service's yaml file.
             *   The new name is saved to the yaml file, and we return nothing to the user, which
             *   means they will receive a generic success message.
             *
             * ```
              import { sdk } from '../sdk'
              import { yamlFile } from '../file-models/config.yml'
    
              const { InputSpec, Value } = sdk
    
              export const inputSpec = InputSpec.of({
                name: Value.text({
                  name: 'Name',
                  description:
                    'When you launch the Hello World UI, it will display "Hello [Name]"',
                  required: true,
                  default: 'World',
                }),
              })
    
              export const setName = sdk.Action.withInput(
                // id
                'set-name',
    
                // metadata
                async ({ effects }) => ({
                  name: 'Set Name',
                  description: 'Set your name so Hello World can say hello to you',
                  warning: null,
                  allowedStatuses: 'any',
                  group: null,
                  visibility: 'enabled',
                }),
    
                // form input specification
                inputSpec,
    
                // optionally pre-fill the input form
                async ({ effects }) => {
                  const name = await yamlFile.read.const(effects)?.name
                  return { name }
                },
    
                // the execution function
                async ({ effects, input }) => yamlFile.merge(input)
              )
             * ```
            */
            withInput: typeof Action.withInput;
            /**
             * @description Use this function to create an action that does not accept form input
             * @param id - a unique ID for this action
             * @param metadata - information describing the action and its availability
             * @param executionFn - execute the action. Optionally return data for the user to view. Must be in the structure of an ActionResult, version "1"
             * @example
             * In this example, we create an action that returns a secret phrase for the user to see.
             *
             * ```
              import { store } from '../file-models/store.json'
              import { sdk } from '../sdk'
    
              export const showSecretPhrase = sdk.Action.withoutInput(
                // id
                'show-secret-phrase',
    
                // metadata
                async ({ effects }) => ({
                  name: 'Show Secret Phrase',
                  description: 'Reveal the secret phrase for Hello World',
                  warning: null,
                  allowedStatuses: 'any',
                  group: null,
                  visibility: 'enabled',
                }),
    
                // the execution function
                async ({ effects }) => ({
                  version: '1',
                  title: 'Secret Phrase',
                  message:
                    'Below is your secret phrase. Use it to gain access to extraordinary places',
                  result: {
                    type: 'single',
                    value: (await store.read.once())?.secretPhrase,
                    copyable: true,
                    qr: true,
                    masked: true,
                  },
                }),
              )
             * ```
            */
            withoutInput: <Id extends T.ActionId>(id: Id, metadata: MaybeFn<Omit<T.ActionMetadata, "hasInput">>, run: Run<{}>) => Action<Id, {}>;
        };
        inputSpecConstants: {
            smtpInputSpec: Value<import("../../base/lib/actions/input/builder/variants").UnionRes<{
                disabled: {
                    name: string;
                    spec: InputSpec<{}, {}>;
                };
                system: {
                    name: string;
                    spec: InputSpec<{
                        customFrom: string | null;
                    }, {
                        customFrom: string | null;
                    }>;
                };
                custom: {
                    name: string;
                    spec: InputSpec<T.SmtpValue, T.SmtpValue>;
                };
            }>, import("../../base/lib/actions/input/builder/variants").UnionResStaticValidatedAs<{
                disabled: {
                    name: string;
                    spec: InputSpec<{}, {}>;
                };
                system: {
                    name: string;
                    spec: InputSpec<{
                        customFrom: string | null;
                    }, {
                        customFrom: string | null;
                    }>;
                };
                custom: {
                    name: string;
                    spec: InputSpec<T.SmtpValue, T.SmtpValue>;
                };
            }>>;
        };
        /**
         * @description Use this function to create a service interface.
         * @param effects
         * @param options
         * @example
         * In this example, we create a standard web UI
         *
         * ```
          const ui = sdk.createInterface(effects, {
            name: 'Web UI',
            id: 'ui',
            description: 'The primary web app for this service.',
            type: 'ui',
            masked: false,
            schemeOverride: null,
            username: null,
            path: '',
            query: {},
          })
         * ```
         */
        createInterface: (effects: Effects, options: {
            /** The human readable name of this service interface. */
            name: string;
            /** A unique ID for this service interface. */
            id: string;
            /** The human readable description. */
            description: string;
            /** Affects how the interface appears to the user. One of: 'ui', 'api', 'p2p'. If 'ui', the user will see an option to open the UI in a new tab */
            type: ServiceInterfaceType;
            /** (optional) prepends the provided username to all URLs. */
            username: null | string;
            /** (optional) appends the provided path to all URLs. */
            path: string;
            /** (optional) appends the provided query params to all URLs. */
            query: Record<string, string>;
            /** (optional) overrides the protocol prefix provided by the bind function.
             *
             * @example `ftp://`
             */
            schemeOverride: {
                ssl: Scheme;
                noSsl: Scheme;
            } | null;
            /** TODO Aiden how would someone include a password in the URL? Whether or not to mask the URLs on the screen, for example, when they contain a password */
            masked: boolean;
        }) => ServiceInterfaceBuilder;
        getSystemSmtp: <E extends Effects>(effects: E) => GetSystemSmtp;
        getSslCerificate: <E extends Effects>(effects: E, hostnames: string[], algorithm?: T.Algorithm) => GetSslCertificate;
        healthCheck: {
            checkPortListening: typeof checkPortListening;
            checkWebUrl: (effects: Effects, url: string, { timeout, successMessage, errorMessage, }?: {
                timeout?: number | undefined;
                successMessage?: string | undefined;
                errorMessage?: string | undefined;
            }) => Promise<import("./health/checkFns").HealthCheckResult>;
            runHealthScript: <Manifest_1 extends T.SDKManifest>(runCommand: string[], subcontainer: SubContainer<Manifest_1>, { timeout, errorMessage, message, }?: {
                timeout?: number | undefined;
                errorMessage?: string | undefined;
                message?: ((res: string) => string) | undefined;
            }) => Promise<import("./health/checkFns").HealthCheckResult>;
        };
        patterns: typeof patterns;
        /**
         * @description Use this function to list every Action offered by the service. Actions will be displayed in the provided order.
         *
         *   By convention, each Action should receive its own file in the "actions" directory.
         * @example
         *
         * ```
          import { sdk } from '../sdk'
          import { config } from './config'
          import { nameToLogs } from './nameToLogs'
  
          export const actions = sdk.Actions.of().addAction(config).addAction(nameToLogs)
         * ```
         */
        Actions: {
            new (actions: {}): Actions<{}>;
            of(): Actions<{}>;
        };
        /**
         * @description Use this function to determine which volumes are backed up when a user creates a backup, including advanced options.
         * @example
         * In this example, we back up the entire "main" volume and nothing else.
         *
         * ```
          import { sdk } from './sdk'
  
          export const { createBackup, restoreBackup } = sdk.setupBackups(
            async ({ effects }) => sdk.Backups.volumes('main'),
          )
         * ```
         * @example
         * In this example, we back up the "main" volume, but exclude hypothetical directory "excludedDir".
         *
         * ```
          import { sdk } from './sdk'
  
          export const { createBackup, restoreBackup } = sdk.setupBackups(async () =>
            sdk.Backups.volumes('main').setOptions({
              exclude: ['excludedDir'],
            }),
          )
         * ```
         */
        setupBackups: (options: SetupBackupsParams<Manifest>) => {
            createBackup: T.ExpectedExports.createBackup;
            restoreInit: import("../../base/lib/inits").InitScript;
        };
        /**
         * @description Use this function to set dependency information.
         * @example
         * In this example, we create a dependency on Hello World >=1.0.0:0, where Hello World must be running and passing its "primary" health check.
         *
         * ```
          export const setDependencies = sdk.setupDependencies(
            async ({ effects }) => {
              return {
                'hello-world': {
                  kind: 'running',
                  versionRange: '>=1.0.0',
                  healthChecks: ['primary'],
                },
              }
            },
          )
         * ```
         */
        setupDependencies: (fn: (options: {
            effects: T.Effects;
        }) => Promise<T.CurrentDependenciesResult<Manifest>>) => (effects: T.Effects) => Promise<null>;
        /**
         * @description Use this function to create an InitScript that runs every time the service initializes (install, update, restore, rebuild, and server bootup)
         */
        setupOnInit: typeof setupOnInit;
        /**
         * @description Use this function to create an UninitScript that runs every time the service uninitializes (update, uninstall, and server shutdown)
         */
        setupOnUninit: typeof setupOnUninit;
        /**
         * @description Use this function to setup what happens when the service initializes.
         *
         *    This happens when the server boots, or a service is installed, updated, or restored
         *
         *    Not every init script does something on every initialization. For example, versions only does something on install or update
         *
         *    These scripts are run in the order they are supplied
         * @example
         *
         * ```
          export const init = sdk.setupInit(
            restoreInit,
            versions,
            setDependencies,
            setInterfaces,
            actions,
            postInstall,
          )
         * ```
         */
        setupInit: typeof setupInit;
        /**
         * @description Use this function to setup what happens when the service uninitializes.
         *
         *    This happens when the server shuts down, or a service is uninstalled or updated
         *
         *    Not every uninit script does something on every uninitialization. For example, versions only does something on uninstall or update
         *
         *    These scripts are run in the order they are supplied
         * @example
         *
         * ```
          export const uninit = sdk.setupUninit(
            versions,
          )
         * ```
         */
        setupUninit: typeof setupUninit;
        /**
         * @description Use this function to determine how this service will be hosted and served. The function executes on service install, service update, and inputSpec save.
         * @param inputSpec - The inputSpec spec of this service as exported from /inputSpec/spec.
         * @param fn - an async function that returns an array of interface receipts. The function always has access to `effects`; it has access to `input` only after inputSpec save, otherwise `input` will be null.
         * @example
         * In this example, we create two UIs from one multi-host, and one API from another multi-host.
         *
         * ```
          export const setInterfaces = sdk.setupInterfaces(
            async ({ effects }) => {
              // ** UI multi-host **
              const uiMulti = sdk.MultiHost.of(effects, 'ui-multi')
              const uiMultiOrigin = await uiMulti.bindPort(80, {
                protocol: 'http',
              })
              // Primary UI
              const primaryUi = sdk.createInterface(effects, {
                name: 'Primary UI',
                id: 'primary-ui',
                description: 'The primary web app for this service.',
                type: 'ui',
                masked: false,
                schemeOverride: null,
                username: null,
                path: '',
                query: {},
              })
              // Admin UI
              const adminUi = sdk.createInterface(effects, {
                name: 'Admin UI',
                id: 'admin-ui',
                description: 'The admin web app for this service.',
                type: 'ui',
                masked: false,
                schemeOverride: null,
                username: null,
                path: '/admin',
                query: {},
              })
              // UI receipt
              const uiReceipt = await uiMultiOrigin.export([primaryUi, adminUi])
         
              // ** API multi-host **
              const apiMulti = sdk.MultiHost.of(effects, 'api-multi')
              const apiMultiOrigin = await apiMulti.bindPort(5959, {
                protocol: 'http',
              })
              // API
              const api = sdk.createInterface(effects, {
                name: 'Admin API',
                id: 'api',
                description: 'The advanced API for this service.',
                type: 'api',
                masked: false,
                schemeOverride: null,
                username: null,
                path: '',
                query: {},
              })
              // API receipt
              const apiReceipt = await apiMultiOrigin.export([api])
         
              // ** Return receipts **
              return [uiReceipt, apiReceipt]
            },
          )
         * ```
         */
        setupInterfaces: import("../../base/lib/interfaces/setupInterfaces").SetupServiceInterfaces;
        setupMain: (fn: (o: {
            effects: Effects;
            started(onTerm: () => PromiseLike<void>): PromiseLike<null>;
        }) => Promise<Daemons<Manifest, any>>) => T.ExpectedExports.main;
        trigger: {
            defaultTrigger: import("./trigger").Trigger;
            cooldownTrigger: typeof cooldownTrigger;
            changeOnFirstSuccess: typeof changeOnFirstSuccess;
            successFailure: (o: {
                duringSuccess: import("./trigger").Trigger;
                duringError: import("./trigger").Trigger;
            }) => import("./trigger").Trigger;
        };
        Mounts: {
            of: () => Mounts<Manifest, never>;
        };
        Backups: {
            ofVolumes: (...volumeNames: Manifest["volumes"][number][]) => Backups<Manifest>;
            ofSyncs: (...syncs: BackupSync<Manifest["volumes"][number]>[]) => Backups<Manifest>;
            withOptions: (options?: Partial<T.SyncOptions>) => Backups<Manifest>;
        };
        InputSpec: {
            /**
             * @description Use this function to define the inputSpec specification that will ultimately present to the user as validated form inputs.
             *
             *   Most form controls are supported, including text, textarea, number, toggle, select, multiselect, list, color, datetime, object (sub form), and union (conditional sub form).
             * @example
             * In this example, we define a inputSpec form with two value: name and makePublic.
             *
             * ```
              import { sdk } from '../sdk'
              const { InputSpec, Value } = sdk
             
              export const inputSpecSpec = InputSpec.of({
                name: Value.text({
                  name: 'Name',
                  description:
                    'When you launch the Hello World UI, it will display "Hello [Name]"',
                  required: true,
                  default: 'World'
                }),
                makePublic: Value.toggle({
                  name: 'Make Public',
                  description: 'Whether or not to expose the service to the network',
                  default: false,
                }),
              })
             * ```
             */
            of: <Spec extends Record<string, Value<any>>>(spec: Spec) => InputSpec<{ [K in keyof Spec]: Spec[K] extends Value<infer T extends any, any> ? T : never; }, { [K_1 in keyof Spec]: Spec[K_1] extends Value<any, infer T_1> ? T_1 : never; }>;
        };
        Daemon: {
            readonly of: <C extends SubContainer<Manifest, Effects> | null>(effects: T.Effects, subcontainer: C, exec: import("./mainFn/Daemons").DaemonCommandType<Manifest, C>) => Promise<Daemon<Manifest, SubContainer<Manifest, Effects> | null>>;
        };
        Daemons: {
            of(effects: Effects, started: ((onTerm: () => PromiseLike<void>) => PromiseLike<null>) | null): Daemons<Manifest, never>;
        };
        SubContainer: {
            /**
             * @description Create a new SubContainer
             * @param effects
             * @param image - what container image to use
             * @param mounts - what to mount to the subcontainer
             * @param name - a name to use to refer to the subcontainer for debugging purposes
             */
            of(effects: Effects, image: {
                imageId: T.ImageId & keyof Manifest["images"];
                sharedRun?: boolean;
            }, mounts: Mounts<Manifest> | null, name: string): Promise<import("./util/SubContainer").SubContainerRc<Manifest, Effects>>;
            /**
             * @description Run a function with a temporary SubContainer
             * @param effects
             * @param image - what container image to use
             * @param mounts - what to mount to the subcontainer
             * @param name - a name to use to refer to the ephemeral subcontainer for debugging purposes
             */
            withTemp<T>(effects: T.Effects, image: {
                imageId: T.ImageId & keyof Manifest["images"];
                sharedRun?: boolean;
            }, mounts: Mounts<Manifest> | null, name: string, fn: (subContainer: SubContainer<Manifest>) => Promise<T>): Promise<T>;
        };
        List: typeof List;
        Value: typeof Value;
        Variants: typeof Variants;
        restart: (effects: Effects) => Promise<null>;
        shutdown: (effects: Effects) => Promise<null>;
        getStatus: (effects: Effects, options: {
            packageId?: PackageId;
            callback?: () => void;
        }) => Promise<T.MainStatus>;
        setDependencies: (effects: Effects, options: {
            dependencies: T.Dependencies;
        }) => Promise<null>;
        getDependencies: (effects: Effects) => Promise<T.DependencyRequirement[]>;
        mount: (effects: Effects, options: T.MountParams) => Promise<string>;
        getInstalledPackages: (effects: Effects) => Promise<string[]>;
        setHealth: (effects: Effects, o: T.SetHealth) => Promise<null>;
        getServicePortForward: (effects: Effects, options: {
            packageId?: PackageId;
            hostId: T.HostId;
            internalPort: number;
        }) => Promise<T.NetInfo>;
        clearBindings: (effects: Effects, options: {
            except: {
                id: T.HostId;
                internalPort: number;
            }[];
        }) => Promise<null>;
        getOsIp: (effects: Effects) => Promise<string>;
        getSslKey: (effects: Effects, options: {
            hostnames: string[];
            algorithm?: "ecdsa" | "ed25519";
        }) => Promise<string>;
        manifest: Manifest;
    };
}
export declare function runCommand<Manifest extends T.SDKManifest>(effects: Effects, image: {
    imageId: keyof Manifest["images"] & T.ImageId;
    sharedRun?: boolean;
}, command: T.CommandType, options: CommandOptions & {
    mounts: Mounts<Manifest> | null;
}, name?: string): Promise<{
    stdout: string | Buffer;
    stderr: string | Buffer;
}>;
export {};
