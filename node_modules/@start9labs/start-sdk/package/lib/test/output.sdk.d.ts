export type Manifest = any;
export declare const sdk: {
    setDataVersion: typeof import("../version/VersionGraph").setDataVersion;
    getDataVersion: typeof import("../version/VersionGraph").getDataVersion;
    action: {
        run: <Input extends Record<string, unknown>>(options: {
            effects: import("../types").Effects;
            actionId: import("../types").ActionId;
            input?: import("../../../base/lib/actions").RunActionInput<Input>;
        }) => Promise<import("../types").ActionResult | null>;
        createTask: <T extends import("../../../base/lib/actions/setupActions").ActionInfo<import("../types").ActionId, any>>(effects: import("../types").Effects, packageId: import("../types").PackageId, action: T, severity: import("../types").TaskSeverity, options?: import("../../../base/lib/actions").TaskOptions<T> | undefined) => Promise<null>;
        createOwnTask: <T extends import("../../../base/lib/actions/setupActions").ActionInfo<import("../types").ActionId, any>>(effects: import("../types").Effects, action: T, severity: import("../types").TaskSeverity, options?: import("../../../base/lib/actions").TaskOptions<T> | undefined) => Promise<null>;
        clearTask: (effects: import("../types").Effects, ...replayIds: string[]) => Promise<null>;
    };
    checkDependencies: <DependencyId extends "remote-test" = "remote-test">(effects: import("../types").Effects, packageIds?: DependencyId[] | undefined) => Promise<import("../../../base/lib/dependencies/dependencies").CheckDependencies<DependencyId>>;
    serviceInterface: {
        getOwn: <E extends import("../types").Effects>(effects: E, id: import("../types").ServiceInterfaceId) => import("../util").GetServiceInterface;
        get: <E extends import("../types").Effects>(effects: E, opts: {
            id: import("../types").ServiceInterfaceId;
            packageId: import("../types").PackageId;
        }) => import("../util").GetServiceInterface;
        getAllOwn: <E extends import("../types").Effects>(effects: E) => import("../../../base/lib/util/getServiceInterfaces").GetServiceInterfaces;
        getAll: <E extends import("../types").Effects>(effects: E, opts: {
            packageId: import("../types").PackageId;
        }) => import("../../../base/lib/util/getServiceInterfaces").GetServiceInterfaces;
    };
    getContainerIp: (effects: import("../types").Effects, options?: Omit<Parameters<import("../types").Effects["getContainerIp"]>[0], "callback">) => {
        const: () => Promise<string>;
        once: () => Promise<string>;
        watch: (abort?: AbortSignal) => import("../../../base/lib/util/Drop").DropGenerator<string, void, unknown>;
        onChange: (callback: (value: string | null, error?: Error) => {
            cancel: boolean;
        } | Promise<{
            cancel: boolean;
        }>) => void;
        waitFor: (pred: (value: string | null) => boolean) => Promise<string | null>;
    };
    MultiHost: {
        of: (effects: import("../types").Effects, id: string) => import("../../../base/lib/interfaces/Host").MultiHost;
    };
    nullIfEmpty: typeof import("../util").nullIfEmpty;
    useEntrypoint: (overrideCmd?: string[]) => import("../types").UseEntrypoint;
    Action: {
        withInput: typeof import("../../../base/lib/actions/setupActions").Action.withInput;
        withoutInput: <Id extends import("../types").ActionId>(id: Id, metadata: import("../../../base/lib/actions/setupActions").MaybeFn<Omit<import("../types").ActionMetadata, "hasInput">>, run: import("../../../base/lib/actions/setupActions").Run<{}>) => import("../../../base/lib/actions/setupActions").Action<Id, {}>;
    };
    inputSpecConstants: {
        smtpInputSpec: import("../../../base/lib/actions/input/builder").Value<import("../../../base/lib/actions/input/builder/variants").UnionRes<{
            disabled: {
                name: string;
                spec: import("../../../base/lib/actions/input/builder").InputSpec<{}, {}>;
            };
            system: {
                name: string;
                spec: import("../../../base/lib/actions/input/builder").InputSpec<{
                    customFrom: string | null;
                }, {
                    customFrom: string | null;
                }>;
            };
            custom: {
                name: string;
                spec: import("../../../base/lib/actions/input/builder").InputSpec<import("../types").SmtpValue, import("../types").SmtpValue>;
            };
        }>, import("../../../base/lib/actions/input/builder/variants").UnionResStaticValidatedAs<{
            disabled: {
                name: string;
                spec: import("../../../base/lib/actions/input/builder").InputSpec<{}, {}>;
            };
            system: {
                name: string;
                spec: import("../../../base/lib/actions/input/builder").InputSpec<{
                    customFrom: string | null;
                }, {
                    customFrom: string | null;
                }>;
            };
            custom: {
                name: string;
                spec: import("../../../base/lib/actions/input/builder").InputSpec<import("../types").SmtpValue, import("../types").SmtpValue>;
            };
        }>>;
    };
    createInterface: (effects: import("../types").Effects, options: {
        name: string;
        id: string;
        description: string;
        type: import("../types").ServiceInterfaceType;
        username: null | string;
        path: string;
        query: Record<string, string>;
        schemeOverride: {
            ssl: import("../../../base/lib/interfaces/Host").Scheme;
            noSsl: import("../../../base/lib/interfaces/Host").Scheme;
        } | null;
        masked: boolean;
    }) => import("../../../base/lib/interfaces/ServiceInterfaceBuilder").ServiceInterfaceBuilder;
    getSystemSmtp: <E extends import("../types").Effects>(effects: E) => import("../util").GetSystemSmtp;
    getSslCerificate: <E extends import("../types").Effects>(effects: E, hostnames: string[], algorithm?: import("../types").Algorithm) => import("../util").GetSslCertificate;
    healthCheck: {
        checkPortListening: typeof import("../health/checkFns").checkPortListening;
        checkWebUrl: (effects: import("../types").Effects, url: string, { timeout, successMessage, errorMessage, }?: {
            timeout?: number | undefined;
            successMessage?: string | undefined;
            errorMessage?: string | undefined;
        }) => Promise<import("../health/checkFns").HealthCheckResult>;
        runHealthScript: <Manifest extends import("../types").SDKManifest>(runCommand: string[], subcontainer: import("..").SubContainer<Manifest>, { timeout, errorMessage, message, }?: {
            timeout?: number | undefined;
            errorMessage?: string | undefined;
            message?: ((res: string) => string) | undefined;
        }) => Promise<import("../health/checkFns").HealthCheckResult>;
    };
    patterns: typeof import("../../../base/lib/util/patterns");
    Actions: {
        new (actions: {}): import("../../../base/lib/actions/setupActions").Actions<{}>;
        of(): import("../../../base/lib/actions/setupActions").Actions<{}>;
    };
    setupBackups: (options: import("../backup/setupBackups").SetupBackupsParams<{
        id: "testOutput";
        title: string;
        license: string;
        wrapperRepo: string;
        upstreamRepo: string;
        supportSite: string;
        marketingSite: string;
        donationUrl: null;
        docsUrl: string;
        description: {
            short: string;
            long: string;
        };
        images: {
            main: {
                source: {
                    dockerTag: string;
                };
                arch: ["aarch64", "x86_64"];
                emulateMissingAs: "aarch64";
            };
        };
        volumes: never[];
        alerts: {
            install: null;
            update: null;
            uninstall: null;
            restore: null;
            start: null;
            stop: null;
        };
        dependencies: {
            "remote-test": {
                description: string;
                optional: false;
                s9pk: string;
            };
        };
    }>) => {
        createBackup: import("../types").ExpectedExports.createBackup;
        restoreInit: import("../../../base/lib/inits").InitScript;
    };
    setupDependencies: (fn: (options: {
        effects: import("../types").Effects;
    }) => Promise<import("../types").CurrentDependenciesResult<{
        id: "testOutput";
        title: string;
        license: string;
        wrapperRepo: string;
        upstreamRepo: string;
        supportSite: string;
        marketingSite: string;
        donationUrl: null;
        docsUrl: string;
        description: {
            short: string;
            long: string;
        };
        images: {
            main: {
                source: {
                    dockerTag: string;
                };
                arch: ["aarch64", "x86_64"];
                emulateMissingAs: "aarch64";
            };
        };
        volumes: never[];
        alerts: {
            install: null;
            update: null;
            uninstall: null;
            restore: null;
            start: null;
            stop: null;
        };
        dependencies: {
            "remote-test": {
                description: string;
                optional: false;
                s9pk: string;
            };
        };
    }>>) => (effects: import("../types").Effects) => Promise<null>;
    setupOnInit: typeof import("../../../base/lib/inits").setupOnInit;
    setupOnUninit: typeof import("../../../base/lib/inits").setupOnUninit;
    setupInit: typeof import("../../../base/lib/inits").setupInit;
    setupUninit: typeof import("../../../base/lib/inits").setupUninit;
    setupInterfaces: import("../../../base/lib/interfaces/setupInterfaces").SetupServiceInterfaces;
    setupMain: (fn: (o: {
        effects: import("../types").Effects;
        started(onTerm: () => PromiseLike<void>): PromiseLike<null>;
    }) => Promise<import("..").Daemons<{
        id: "testOutput";
        title: string;
        license: string;
        wrapperRepo: string;
        upstreamRepo: string;
        supportSite: string;
        marketingSite: string;
        donationUrl: null;
        docsUrl: string;
        description: {
            short: string;
            long: string;
        };
        images: {
            main: {
                source: {
                    dockerTag: string;
                };
                arch: ["aarch64", "x86_64"];
                emulateMissingAs: "aarch64";
            };
        };
        volumes: never[];
        alerts: {
            install: null;
            update: null;
            uninstall: null;
            restore: null;
            start: null;
            stop: null;
        };
        dependencies: {
            "remote-test": {
                description: string;
                optional: false;
                s9pk: string;
            };
        };
    }, any>>) => import("../types").ExpectedExports.main;
    trigger: {
        defaultTrigger: import("../trigger").Trigger;
        cooldownTrigger: typeof import("../trigger").cooldownTrigger;
        changeOnFirstSuccess: typeof import("../trigger").changeOnFirstSuccess;
        successFailure: (o: {
            duringSuccess: import("../trigger").Trigger;
            duringError: import("../trigger").Trigger;
        }) => import("../trigger").Trigger;
    };
    Mounts: {
        of: () => import("../mainFn/Mounts").Mounts<{
            id: "testOutput";
            title: string;
            license: string;
            wrapperRepo: string;
            upstreamRepo: string;
            supportSite: string;
            marketingSite: string;
            donationUrl: null;
            docsUrl: string;
            description: {
                short: string;
                long: string;
            };
            images: {
                main: {
                    source: {
                        dockerTag: string;
                    };
                    arch: ["aarch64", "x86_64"];
                    emulateMissingAs: "aarch64";
                };
            };
            volumes: never[];
            alerts: {
                install: null;
                update: null;
                uninstall: null;
                restore: null;
                start: null;
                stop: null;
            };
            dependencies: {
                "remote-test": {
                    description: string;
                    optional: false;
                    s9pk: string;
                };
            };
        }, never>;
    };
    Backups: {
        ofVolumes: (...volumeNames: never[]) => import("../backup/Backups").Backups<{
            id: "testOutput";
            title: string;
            license: string;
            wrapperRepo: string;
            upstreamRepo: string;
            supportSite: string;
            marketingSite: string;
            donationUrl: null;
            docsUrl: string;
            description: {
                short: string;
                long: string;
            };
            images: {
                main: {
                    source: {
                        dockerTag: string;
                    };
                    arch: ["aarch64", "x86_64"];
                    emulateMissingAs: "aarch64";
                };
            };
            volumes: never[];
            alerts: {
                install: null;
                update: null;
                uninstall: null;
                restore: null;
                start: null;
                stop: null;
            };
            dependencies: {
                "remote-test": {
                    description: string;
                    optional: false;
                    s9pk: string;
                };
            };
        }>;
        ofSyncs: (...syncs: import("../backup/Backups").BackupSync<never>[]) => import("../backup/Backups").Backups<{
            id: "testOutput";
            title: string;
            license: string;
            wrapperRepo: string;
            upstreamRepo: string;
            supportSite: string;
            marketingSite: string;
            donationUrl: null;
            docsUrl: string;
            description: {
                short: string;
                long: string;
            };
            images: {
                main: {
                    source: {
                        dockerTag: string;
                    };
                    arch: ["aarch64", "x86_64"];
                    emulateMissingAs: "aarch64";
                };
            };
            volumes: never[];
            alerts: {
                install: null;
                update: null;
                uninstall: null;
                restore: null;
                start: null;
                stop: null;
            };
            dependencies: {
                "remote-test": {
                    description: string;
                    optional: false;
                    s9pk: string;
                };
            };
        }>;
        withOptions: (options?: Partial<import("../types").SyncOptions>) => import("../backup/Backups").Backups<{
            id: "testOutput";
            title: string;
            license: string;
            wrapperRepo: string;
            upstreamRepo: string;
            supportSite: string;
            marketingSite: string;
            donationUrl: null;
            docsUrl: string;
            description: {
                short: string;
                long: string;
            };
            images: {
                main: {
                    source: {
                        dockerTag: string;
                    };
                    arch: ["aarch64", "x86_64"];
                    emulateMissingAs: "aarch64";
                };
            };
            volumes: never[];
            alerts: {
                install: null;
                update: null;
                uninstall: null;
                restore: null;
                start: null;
                stop: null;
            };
            dependencies: {
                "remote-test": {
                    description: string;
                    optional: false;
                    s9pk: string;
                };
            };
        }>;
    };
    InputSpec: {
        of: <Spec extends Record<string, import("../../../base/lib/actions/input/builder").Value<any>>>(spec: Spec) => import("../../../base/lib/actions/input/builder").InputSpec<{ [K in keyof Spec]: Spec[K] extends import("../../../base/lib/actions/input/builder").Value<infer T extends any, any> ? T : never; }, { [K_1 in keyof Spec]: Spec[K_1] extends import("../../../base/lib/actions/input/builder").Value<any, infer T_1> ? T_1 : never; }>;
    };
    Daemon: {
        readonly of: <C extends import("..").SubContainer<Manifest, import("../types").Effects> | null>(effects: import("../types").Effects, subcontainer: C, exec: import("../mainFn/Daemons").DaemonCommandType<Manifest, C>) => Promise<import("../mainFn/Daemon").Daemon<Manifest, import("..").SubContainer<Manifest, import("../types").Effects> | null>>;
    };
    Daemons: {
        of(effects: import("../types").Effects, started: ((onTerm: () => PromiseLike<void>) => PromiseLike<null>) | null): import("..").Daemons<{
            id: "testOutput";
            title: string;
            license: string;
            wrapperRepo: string;
            upstreamRepo: string;
            supportSite: string;
            marketingSite: string;
            donationUrl: null;
            docsUrl: string;
            description: {
                short: string;
                long: string;
            };
            images: {
                main: {
                    source: {
                        dockerTag: string;
                    };
                    arch: ["aarch64", "x86_64"];
                    emulateMissingAs: "aarch64";
                };
            };
            volumes: never[];
            alerts: {
                install: null;
                update: null;
                uninstall: null;
                restore: null;
                start: null;
                stop: null;
            };
            dependencies: {
                "remote-test": {
                    description: string;
                    optional: false;
                    s9pk: string;
                };
            };
        }, never>;
    };
    SubContainer: {
        of(effects: import("../types").Effects, image: {
            imageId: "main";
            sharedRun?: boolean;
        }, mounts: import("../mainFn/Mounts").Mounts<{
            id: "testOutput";
            title: string;
            license: string;
            wrapperRepo: string;
            upstreamRepo: string;
            supportSite: string;
            marketingSite: string;
            donationUrl: null;
            docsUrl: string;
            description: {
                short: string;
                long: string;
            };
            images: {
                main: {
                    source: {
                        dockerTag: string;
                    };
                    arch: ["aarch64", "x86_64"];
                    emulateMissingAs: "aarch64";
                };
            };
            volumes: never[];
            alerts: {
                install: null;
                update: null;
                uninstall: null;
                restore: null;
                start: null;
                stop: null;
            };
            dependencies: {
                "remote-test": {
                    description: string;
                    optional: false;
                    s9pk: string;
                };
            };
        }, never> | null, name: string): Promise<import("../util/SubContainer").SubContainerRc<{
            id: "testOutput";
            title: string;
            license: string;
            wrapperRepo: string;
            upstreamRepo: string;
            supportSite: string;
            marketingSite: string;
            donationUrl: null;
            docsUrl: string;
            description: {
                short: string;
                long: string;
            };
            images: {
                main: {
                    source: {
                        dockerTag: string;
                    };
                    arch: ["aarch64", "x86_64"];
                    emulateMissingAs: "aarch64";
                };
            };
            volumes: never[];
            alerts: {
                install: null;
                update: null;
                uninstall: null;
                restore: null;
                start: null;
                stop: null;
            };
            dependencies: {
                "remote-test": {
                    description: string;
                    optional: false;
                    s9pk: string;
                };
            };
        }, import("../types").Effects>>;
        withTemp<T>(effects: import("../types").Effects, image: {
            imageId: "main";
            sharedRun?: boolean;
        }, mounts: import("../mainFn/Mounts").Mounts<{
            id: "testOutput";
            title: string;
            license: string;
            wrapperRepo: string;
            upstreamRepo: string;
            supportSite: string;
            marketingSite: string;
            donationUrl: null;
            docsUrl: string;
            description: {
                short: string;
                long: string;
            };
            images: {
                main: {
                    source: {
                        dockerTag: string;
                    };
                    arch: ["aarch64", "x86_64"];
                    emulateMissingAs: "aarch64";
                };
            };
            volumes: never[];
            alerts: {
                install: null;
                update: null;
                uninstall: null;
                restore: null;
                start: null;
                stop: null;
            };
            dependencies: {
                "remote-test": {
                    description: string;
                    optional: false;
                    s9pk: string;
                };
            };
        }, never> | null, name: string, fn: (subContainer: import("..").SubContainer<{
            id: "testOutput";
            title: string;
            license: string;
            wrapperRepo: string;
            upstreamRepo: string;
            supportSite: string;
            marketingSite: string;
            donationUrl: null;
            docsUrl: string;
            description: {
                short: string;
                long: string;
            };
            images: {
                main: {
                    source: {
                        dockerTag: string;
                    };
                    arch: ["aarch64", "x86_64"];
                    emulateMissingAs: "aarch64";
                };
            };
            volumes: never[];
            alerts: {
                install: null;
                update: null;
                uninstall: null;
                restore: null;
                start: null;
                stop: null;
            };
            dependencies: {
                "remote-test": {
                    description: string;
                    optional: false;
                    s9pk: string;
                };
            };
        }, import("../types").Effects>) => Promise<T>): Promise<T>;
    };
    List: typeof import("../../../base/lib/actions/input/builder").List;
    Value: typeof import("../../../base/lib/actions/input/builder").Value;
    Variants: typeof import("../../../base/lib/actions/input/builder").Variants;
    restart: (effects: import("../types").Effects) => Promise<null>;
    shutdown: (effects: import("../types").Effects) => Promise<null>;
    getStatus: (effects: import("../types").Effects, options: {
        packageId?: import("../types").PackageId;
        callback?: () => void;
    }) => Promise<import("../types").MainStatus>;
    setDependencies: (effects: import("../types").Effects, options: {
        dependencies: import("../types").Dependencies;
    }) => Promise<null>;
    getDependencies: (effects: import("../types").Effects) => Promise<import("../types").DependencyRequirement[]>;
    mount: (effects: import("../types").Effects, options: import("../types").MountParams) => Promise<string>;
    getInstalledPackages: (effects: import("../types").Effects) => Promise<string[]>;
    setHealth: (effects: import("../types").Effects, o: import("../types").SetHealth) => Promise<null>;
    getServicePortForward: (effects: import("../types").Effects, options: {
        packageId?: import("../types").PackageId;
        hostId: import("../types").HostId;
        internalPort: number;
    }) => Promise<import("../types").NetInfo>;
    clearBindings: (effects: import("../types").Effects, options: {
        except: {
            id: import("../types").HostId;
            internalPort: number;
        }[];
    }) => Promise<null>;
    getOsIp: (effects: import("../types").Effects) => Promise<string>;
    getSslKey: (effects: import("../types").Effects, options: {
        hostnames: string[];
        algorithm?: "ecdsa" | "ed25519";
    }) => Promise<string>;
    manifest: {
        id: "testOutput";
        title: string;
        license: string;
        wrapperRepo: string;
        upstreamRepo: string;
        supportSite: string;
        marketingSite: string;
        donationUrl: null;
        docsUrl: string;
        description: {
            short: string;
            long: string;
        };
        images: {
            main: {
                source: {
                    dockerTag: string;
                };
                arch: ["aarch64", "x86_64"];
                emulateMissingAs: "aarch64";
            };
        };
        volumes: never[];
        alerts: {
            install: null;
            update: null;
            uninstall: null;
            restore: null;
            start: null;
            stop: null;
        };
        dependencies: {
            "remote-test": {
                description: string;
                optional: false;
                s9pk: string;
            };
        };
    };
};
