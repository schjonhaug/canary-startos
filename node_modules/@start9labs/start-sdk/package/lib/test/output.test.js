"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.testOutput = testOutput;
const output_1 = require("./output");
const oldSpecToBuilder_1 = require("../../scripts/oldSpecToBuilder");
const util_1 = require("../../../base/lib/util");
function testOutput() {
    return () => null;
}
/// Testing the types of the input spec
testOutput()(null);
testOutput()(null);
testOutput()(null);
testOutput()(null);
testOutput()(null);
testOutput()(null);
testOutput()(null);
testOutput()(null);
testOutput()(null);
testOutput()(null);
// @ts-expect-error Because enable should be a boolean
testOutput()(null);
// prettier-ignore
// @ts-expect-error Expect that the string is the one above
testOutput()(null);
/// Here we test the output of the matchInputSpecSpec function
describe("Inputs", () => {
    const validInput = {
        mediasources: ["filebrowser"],
        testListUnion: [
            {
                union: { selection: "lnd", value: { name: "string" } },
            },
        ],
        rpc: {
            enable: true,
            bio: "This is a bio",
            username: "test",
            password: "test",
            advanced: {
                auth: ["test"],
                serialversion: "segwit",
                servertimeout: 6,
                threads: 3,
                workqueue: 9,
            },
        },
        "zmq-enabled": false,
        txindex: false,
        wallet: { enable: false, avoidpartialspends: false, discardfee: 0.0001 },
        advanced: {
            mempool: {
                maxmempool: 1,
                persistmempool: true,
                mempoolexpiry: 23,
                mempoolfullrbf: true,
            },
            peers: {
                listen: true,
                onlyconnect: true,
                onlyonion: true,
                addnode: [
                    {
                        hostname: "test",
                        port: 1,
                    },
                ],
            },
            dbcache: 5,
            pruning: {
                selection: "disabled",
                value: { disabled: {} },
            },
            blockfilters: {
                blockfilterindex: false,
                peerblockfilters: false,
            },
            bloomfilters: { peerbloomfilters: false },
        },
    };
    test("test valid input", async () => {
        const { validator } = await output_1.inputSpecSpec.build({});
        const output = validator.unsafeCast(validInput);
        expect(output).toEqual(validInput);
    });
    test("test no longer care about the conversion of min/max and validating", async () => {
        const { validator } = await output_1.inputSpecSpec.build({});
        validator.unsafeCast((0, util_1.deepMerge)({}, validInput, { rpc: { advanced: { threads: 0 } } }));
    });
    test("test errors should throw for number in string", async () => {
        const { validator } = await output_1.inputSpecSpec.build({});
        expect(() => validator.unsafeCast((0, util_1.deepMerge)({}, validInput, { rpc: { enable: 2 } }))).toThrowError();
    });
    test("Test that we set serialversion to something not segwit or non-segwit", async () => {
        const { validator } = await output_1.inputSpecSpec.build({});
        expect(() => validator.unsafeCast((0, util_1.deepMerge)({}, validInput, {
            rpc: { advanced: { serialversion: "testing" } },
        }))).toThrowError();
    });
});
describe("camelCase", () => {
    test("'EquipmentClass name'", () => {
        expect((0, oldSpecToBuilder_1.camelCase)("EquipmentClass name")).toEqual("equipmentClassName");
    });
    test("'Equipment className'", () => {
        expect((0, oldSpecToBuilder_1.camelCase)("Equipment className")).toEqual("equipmentClassName");
    });
    test("'equipment class name'", () => {
        expect((0, oldSpecToBuilder_1.camelCase)("equipment class name")).toEqual("equipmentClassName");
    });
    test("'Equipment Class Name'", () => {
        expect((0, oldSpecToBuilder_1.camelCase)("Equipment Class Name")).toEqual("equipmentClassName");
    });
    test("'hyphen-name-format'", () => {
        expect((0, oldSpecToBuilder_1.camelCase)("hyphen-name-format")).toEqual("hyphenNameFormat");
    });
    test("'underscore_name_format'", () => {
        expect((0, oldSpecToBuilder_1.camelCase)("underscore_name_format")).toEqual("underscoreNameFormat");
    });
});
//# sourceMappingURL=output.test.js.map