"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const output_test_1 = require("./output.test");
const inputSpec_1 = require("../../../base/lib/actions/input/builder/inputSpec");
const list_1 = require("../../../base/lib/actions/input/builder/list");
const value_1 = require("../../../base/lib/actions/input/builder/value");
const variants_1 = require("../../../base/lib/actions/input/builder/variants");
const setupManifest_1 = require("../manifest/setupManifest");
const StartSdk_1 = require("../StartSdk");
describe("builder tests", () => {
    test("text", async () => {
        const bitcoinPropertiesBuilt = await inputSpec_1.InputSpec.of({
            "peer-tor-address": value_1.Value.text({
                name: "Peer tor address",
                description: "The Tor address of the peer interface",
                required: true,
                default: null,
            }),
        })
            .build({})
            .then((a) => a.spec);
        expect(bitcoinPropertiesBuilt).toMatchObject({
            "peer-tor-address": {
                type: "text",
                description: "The Tor address of the peer interface",
                warning: null,
                masked: false,
                placeholder: null,
                minLength: null,
                maxLength: null,
                patterns: [],
                disabled: false,
                inputmode: "text",
                name: "Peer tor address",
                required: true,
                default: null,
            },
        });
    });
});
describe("values", () => {
    test("toggle", async () => {
        const value = await value_1.Value.toggle({
            name: "Testing",
            description: null,
            warning: null,
            default: false,
        }).build({});
        const validator = value.validator;
        validator.unsafeCast(false);
        (0, output_test_1.testOutput)()(null);
    });
    test("text", async () => {
        const value = await value_1.Value.text({
            name: "Testing",
            required: true,
            default: null,
        }).build({});
        const validator = value.validator;
        const rawIs = value.spec;
        validator.unsafeCast("test text");
        expect(() => validator.unsafeCast(null)).toThrowError();
        (0, output_test_1.testOutput)()(null);
    });
    test("text with default", async () => {
        const value = await value_1.Value.text({
            name: "Testing",
            required: true,
            default: "this is a default value",
        }).build({});
        const validator = value.validator;
        const rawIs = value.spec;
        validator.unsafeCast("test text");
        expect(() => validator.unsafeCast(null)).toThrowError();
        (0, output_test_1.testOutput)()(null);
    });
    test("optional text", async () => {
        const value = await value_1.Value.text({
            name: "Testing",
            required: false,
            default: null,
        }).build({});
        const validator = value.validator;
        const rawIs = value.spec;
        validator.unsafeCast("test text");
        validator.unsafeCast(null);
        (0, output_test_1.testOutput)()(null);
    });
    test("color", async () => {
        const value = await value_1.Value.color({
            name: "Testing",
            required: false,
            default: null,
            description: null,
            warning: null,
        }).build({});
        const validator = value.validator;
        validator.unsafeCast("#000000");
        (0, output_test_1.testOutput)()(null);
    });
    test("datetime", async () => {
        const value = await value_1.Value.datetime({
            name: "Testing",
            required: true,
            default: null,
            description: null,
            warning: null,
            inputmode: "date",
            min: null,
            max: null,
        }).build({});
        const validator = value.validator;
        validator.unsafeCast("2021-01-01");
        (0, output_test_1.testOutput)()(null);
    });
    test("optional datetime", async () => {
        const value = await value_1.Value.datetime({
            name: "Testing",
            required: false,
            default: null,
            description: null,
            warning: null,
            inputmode: "date",
            min: null,
            max: null,
        }).build({});
        const validator = value.validator;
        validator.unsafeCast("2021-01-01");
        (0, output_test_1.testOutput)()(null);
    });
    test("textarea", async () => {
        const value = await value_1.Value.textarea({
            name: "Testing",
            required: false,
            default: null,
            description: null,
            warning: null,
            minLength: null,
            maxLength: null,
            minRows: 3,
            maxRows: 6,
            placeholder: null,
        }).build({});
        const validator = value.validator;
        validator.unsafeCast("test text");
        (0, output_test_1.testOutput)()(null);
    });
    test("number", async () => {
        const value = await value_1.Value.number({
            name: "Testing",
            required: true,
            default: null,
            integer: false,
            description: null,
            warning: null,
            min: null,
            max: null,
            step: null,
            units: null,
            placeholder: null,
        }).build({});
        const validator = value.validator;
        validator.unsafeCast(2);
        (0, output_test_1.testOutput)()(null);
    });
    test("optional number", async () => {
        const value = await value_1.Value.number({
            name: "Testing",
            required: false,
            default: null,
            integer: false,
            description: null,
            warning: null,
            min: null,
            max: null,
            step: null,
            units: null,
            placeholder: null,
        }).build({});
        const validator = value.validator;
        validator.unsafeCast(2);
        (0, output_test_1.testOutput)()(null);
    });
    test("select", async () => {
        const value = await value_1.Value.select({
            name: "Testing",
            default: "a",
            values: {
                a: "A",
                b: "B",
            },
            description: null,
            warning: null,
        }).build({});
        const validator = value.validator;
        validator.unsafeCast("a");
        validator.unsafeCast("b");
        expect(() => validator.unsafeCast("c")).toThrowError();
        (0, output_test_1.testOutput)()(null);
    });
    test("nullable select", async () => {
        const value = await value_1.Value.select({
            name: "Testing",
            default: "a",
            values: {
                a: "A",
                b: "B",
            },
            description: null,
            warning: null,
        }).build({});
        const validator = value.validator;
        validator.unsafeCast("a");
        validator.unsafeCast("b");
        (0, output_test_1.testOutput)()(null);
    });
    test("multiselect", async () => {
        const value = await value_1.Value.multiselect({
            name: "Testing",
            values: {
                a: "A",
                b: "B",
            },
            default: [],
            description: null,
            warning: null,
            minLength: null,
            maxLength: null,
        }).build({});
        const validator = value.validator;
        validator.unsafeCast([]);
        validator.unsafeCast(["a", "b"]);
        expect(() => validator.unsafeCast(["e"])).toThrowError();
        expect(() => validator.unsafeCast([4])).toThrowError();
        (0, output_test_1.testOutput)()(null);
    });
    test("object", async () => {
        const value = await value_1.Value.object({
            name: "Testing",
            description: null,
        }, inputSpec_1.InputSpec.of({
            a: value_1.Value.toggle({
                name: "test",
                description: null,
                warning: null,
                default: false,
            }),
        })).build({});
        const validator = value.validator;
        validator.unsafeCast({ a: true });
        (0, output_test_1.testOutput)()(null);
    });
    test("union", async () => {
        const value = await value_1.Value.union({
            name: "Testing",
            default: "a",
            description: null,
            warning: null,
            variants: variants_1.Variants.of({
                a: {
                    name: "a",
                    spec: inputSpec_1.InputSpec.of({
                        b: value_1.Value.toggle({
                            name: "b",
                            description: null,
                            warning: null,
                            default: false,
                        }),
                    }),
                },
            }),
        }).build({});
        const validator = value.validator;
        validator.unsafeCast({ selection: "a", value: { b: false } });
        (0, output_test_1.testOutput)()(null);
    });
    describe("dynamic", () => {
        const fakeOptions = {
            inputSpec: "inputSpec",
            effects: "effects",
            utils: "utils",
        };
        test("toggle", async () => {
            const value = await value_1.Value.dynamicToggle(async () => ({
                name: "Testing",
                description: null,
                warning: null,
                default: false,
            })).build({});
            const validator = value.validator;
            validator.unsafeCast(false);
            expect(() => validator.unsafeCast(null)).toThrowError();
            (0, output_test_1.testOutput)()(null);
            expect(value.spec).toMatchObject({
                name: "Testing",
                description: null,
                warning: null,
                default: false,
            });
        });
        test("text", async () => {
            const value = await value_1.Value.dynamicText(async () => ({
                name: "Testing",
                required: false,
                default: null,
            })).build({});
            const validator = value.validator;
            const rawIs = value.spec;
            validator.unsafeCast("test text");
            validator.unsafeCast(null);
            (0, output_test_1.testOutput)()(null);
            expect(value.spec).toMatchObject({
                name: "Testing",
                required: false,
                default: null,
            });
        });
        test("text with default", async () => {
            const value = await value_1.Value.dynamicText(async () => ({
                name: "Testing",
                required: false,
                default: "this is a default value",
            })).build({});
            const validator = value.validator;
            validator.unsafeCast("test text");
            validator.unsafeCast(null);
            (0, output_test_1.testOutput)()(null);
            expect(value.spec).toMatchObject({
                name: "Testing",
                required: false,
                default: "this is a default value",
            });
        });
        test("optional text", async () => {
            const value = await value_1.Value.dynamicText(async () => ({
                name: "Testing",
                required: false,
                default: null,
            })).build({});
            const validator = value.validator;
            const rawIs = value.spec;
            validator.unsafeCast("test text");
            validator.unsafeCast(null);
            (0, output_test_1.testOutput)()(null);
            expect(value.spec).toMatchObject({
                name: "Testing",
                required: false,
                default: null,
            });
        });
        test("color", async () => {
            const value = await value_1.Value.dynamicColor(async () => ({
                name: "Testing",
                required: false,
                default: null,
                description: null,
                warning: null,
            })).build({});
            const validator = value.validator;
            validator.unsafeCast("#000000");
            validator.unsafeCast(null);
            (0, output_test_1.testOutput)()(null);
            expect(value.spec).toMatchObject({
                name: "Testing",
                required: false,
                default: null,
                description: null,
                warning: null,
            });
        });
        test("datetime", async () => {
            const sdk = StartSdk_1.StartSdk.of()
                .withManifest((0, setupManifest_1.setupManifest)({
                id: "testOutput",
                title: "",
                license: "",
                wrapperRepo: "",
                upstreamRepo: "",
                supportSite: "",
                marketingSite: "",
                donationUrl: null,
                docsUrl: "",
                description: {
                    short: "",
                    long: "",
                },
                images: {},
                volumes: [],
                alerts: {
                    install: null,
                    update: null,
                    uninstall: null,
                    restore: null,
                    start: null,
                    stop: null,
                },
                dependencies: {
                    "remote-test": {
                        description: "",
                        optional: true,
                        s9pk: "https://example.com/remote-test.s9pk",
                    },
                },
            }))
                .build(true);
            const value = await value_1.Value.dynamicDatetime(async ({ effects }) => {
                return {
                    name: "Testing",
                    required: false,
                    default: null,
                    inputmode: "date",
                };
            }).build({});
            const validator = value.validator;
            validator.unsafeCast("2021-01-01");
            validator.unsafeCast(null);
            (0, output_test_1.testOutput)()(null);
            expect(value.spec).toMatchObject({
                name: "Testing",
                required: false,
                default: null,
                description: null,
                warning: null,
                inputmode: "date",
            });
        });
        test("textarea", async () => {
            const value = await value_1.Value.dynamicTextarea(async () => ({
                name: "Testing",
                required: false,
                default: null,
                description: null,
                warning: null,
                minLength: null,
                maxLength: null,
                minRows: 3,
                maxRows: 6,
                placeholder: null,
            })).build({});
            const validator = value.validator;
            validator.unsafeCast("test text");
            (0, output_test_1.testOutput)()(null);
            expect(value.spec).toMatchObject({
                name: "Testing",
                required: false,
            });
        });
        test("number", async () => {
            const value = await value_1.Value.dynamicNumber(() => ({
                name: "Testing",
                required: false,
                default: null,
                integer: false,
                description: null,
                warning: null,
                min: null,
                max: null,
                step: null,
                units: null,
                placeholder: null,
            })).build({});
            const validator = value.validator;
            validator.unsafeCast(2);
            validator.unsafeCast(null);
            expect(() => validator.unsafeCast("null")).toThrowError();
            (0, output_test_1.testOutput)()(null);
            expect(value.spec).toMatchObject({
                name: "Testing",
                required: false,
            });
        });
        test("select", async () => {
            const value = await value_1.Value.dynamicSelect(() => ({
                name: "Testing",
                default: "a",
                values: {
                    a: "A",
                    b: "B",
                },
                description: null,
                warning: null,
            })).build({});
            const validator = value.validator;
            validator.unsafeCast("a");
            validator.unsafeCast("b");
            (0, output_test_1.testOutput)()(null);
            expect(value.spec).toMatchObject({
                name: "Testing",
            });
        });
        test("multiselect", async () => {
            const value = await value_1.Value.dynamicMultiselect(() => ({
                name: "Testing",
                values: {
                    a: "A",
                    b: "B",
                },
                default: [],
                description: null,
                warning: null,
                minLength: null,
                maxLength: null,
            })).build({});
            const validator = value.validator;
            validator.unsafeCast([]);
            validator.unsafeCast(["a", "b"]);
            expect(() => validator.unsafeCast([4])).toThrowError();
            expect(() => validator.unsafeCast(null)).toThrowError();
            (0, output_test_1.testOutput)()(null);
            expect(value.spec).toMatchObject({
                name: "Testing",
                default: [],
            });
        });
    });
    describe("filtering", () => {
        test("union", async () => {
            const value = await value_1.Value.dynamicUnion(() => ({
                name: "Testing",
                default: "a",
                description: null,
                warning: null,
                disabled: ["a", "c"],
                variants: variants_1.Variants.of({
                    a: {
                        name: "a",
                        spec: inputSpec_1.InputSpec.of({
                            b: value_1.Value.toggle({
                                name: "b",
                                description: null,
                                warning: null,
                                default: false,
                            }),
                        }),
                    },
                    b: {
                        name: "b",
                        spec: inputSpec_1.InputSpec.of({
                            b: value_1.Value.toggle({
                                name: "b",
                                description: null,
                                warning: null,
                                default: false,
                            }),
                        }),
                    },
                }),
            })).build({});
            const validator = value.validator;
            validator.unsafeCast({ selection: "a", value: { b: false } });
            (0, output_test_1.testOutput)()(null);
            const built = value.spec;
            expect(built).toMatchObject({
                name: "Testing",
                variants: {
                    b: {},
                },
            });
            expect(built).toMatchObject({
                name: "Testing",
                variants: {
                    a: {},
                    b: {},
                },
            });
            expect(built).toMatchObject({
                name: "Testing",
                variants: {
                    a: {},
                    b: {},
                },
                disabled: ["a", "c"],
            });
        });
    });
    test("dynamic union", async () => {
        const value = await value_1.Value.dynamicUnion(() => ({
            disabled: ["a", "c"],
            name: "Testing",
            default: "b",
            description: null,
            warning: null,
            variants: variants_1.Variants.of({
                a: {
                    name: "a",
                    spec: inputSpec_1.InputSpec.of({
                        b: value_1.Value.toggle({
                            name: "b",
                            description: null,
                            warning: null,
                            default: false,
                        }),
                    }),
                },
                b: {
                    name: "b",
                    spec: inputSpec_1.InputSpec.of({
                        b: value_1.Value.toggle({
                            name: "b",
                            description: null,
                            warning: null,
                            default: false,
                        }),
                    }),
                },
            }),
        })).build({});
        const validator = value.validator;
        validator.unsafeCast({ selection: "a", value: { b: false } });
        (0, output_test_1.testOutput)()(null);
        const built = value.spec;
        expect(built).toMatchObject({
            name: "Testing",
            variants: {
                b: {},
            },
        });
        expect(built).toMatchObject({
            name: "Testing",
            variants: {
                a: {},
                b: {},
            },
        });
        expect(built).toMatchObject({
            name: "Testing",
            variants: {
                a: {},
                b: {},
            },
            disabled: ["a", "c"],
        });
    });
});
describe("Builder List", () => {
    test("obj", async () => {
        const value = await value_1.Value.list(list_1.List.obj({
            name: "test",
        }, {
            spec: inputSpec_1.InputSpec.of({
                test: value_1.Value.toggle({
                    name: "test",
                    description: null,
                    warning: null,
                    default: false,
                }),
            }),
        })).build({});
        const validator = value.validator;
        validator.unsafeCast([{ test: true }]);
        (0, output_test_1.testOutput)()(null);
    });
    test("text", async () => {
        const value = await value_1.Value.list(list_1.List.text({
            name: "test",
        }, {
            patterns: [],
        })).build({});
        const validator = value.validator;
        validator.unsafeCast(["test", "text"]);
        (0, output_test_1.testOutput)()(null);
    });
    describe("dynamic", () => {
        test("text", async () => {
            const value = await value_1.Value.list(list_1.List.dynamicText(() => ({
                name: "test",
                spec: { patterns: [] },
            }))).build({});
            const validator = value.validator;
            validator.unsafeCast(["test", "text"]);
            expect(() => validator.unsafeCast([3, 4])).toThrowError();
            expect(() => validator.unsafeCast(null)).toThrowError();
            (0, output_test_1.testOutput)()(null);
            expect(value.spec).toMatchObject({
                name: "test",
                spec: { patterns: [] },
            });
        });
    });
});
describe("Nested nullable values", () => {
    test("Testing text", async () => {
        const value = await inputSpec_1.InputSpec.of({
            a: value_1.Value.text({
                name: "Temp Name",
                description: "If no name is provided, the name from inputSpec will be used",
                required: false,
                default: null,
            }),
        }).build({});
        const validator = value.validator;
        validator.unsafeCast({ a: null });
        validator.unsafeCast({ a: "test" });
        expect(() => validator.unsafeCast({ a: 4 })).toThrowError();
        (0, output_test_1.testOutput)()(null);
    });
    test("Testing number", async () => {
        const value = await inputSpec_1.InputSpec.of({
            a: value_1.Value.number({
                name: "Temp Name",
                description: "If no name is provided, the name from inputSpec will be used",
                required: false,
                default: null,
                warning: null,
                placeholder: null,
                integer: false,
                min: null,
                max: null,
                step: null,
                units: null,
            }),
        }).build({});
        const validator = value.validator;
        validator.unsafeCast({ a: null });
        validator.unsafeCast({ a: 5 });
        expect(() => validator.unsafeCast({ a: "4" })).toThrowError();
        (0, output_test_1.testOutput)()(null);
    });
    test("Testing color", async () => {
        const value = await inputSpec_1.InputSpec.of({
            a: value_1.Value.color({
                name: "Temp Name",
                description: "If no name is provided, the name from inputSpec will be used",
                required: false,
                default: null,
                warning: null,
            }),
        }).build({});
        const validator = value.validator;
        validator.unsafeCast({ a: null });
        validator.unsafeCast({ a: "5" });
        expect(() => validator.unsafeCast({ a: 4 })).toThrowError();
        (0, output_test_1.testOutput)()(null);
    });
    test("Testing select", async () => {
        const value = await inputSpec_1.InputSpec.of({
            a: value_1.Value.select({
                name: "Temp Name",
                description: "If no name is provided, the name from inputSpec will be used",
                default: "a",
                warning: null,
                values: {
                    a: "A",
                },
            }),
        }).build({});
        const higher = await value_1.Value.select({
            name: "Temp Name",
            description: "If no name is provided, the name from inputSpec will be used",
            default: "a",
            warning: null,
            values: {
                a: "A",
            },
        }).build({});
        const validator = value.validator;
        validator.unsafeCast({ a: "a" });
        expect(() => validator.unsafeCast({ a: "4" })).toThrowError();
        (0, output_test_1.testOutput)()(null);
    });
    test("Testing multiselect", async () => {
        const value = await inputSpec_1.InputSpec.of({
            a: value_1.Value.multiselect({
                name: "Temp Name",
                description: "If no name is provided, the name from inputSpec will be used",
                warning: null,
                default: [],
                values: {
                    a: "A",
                },
                minLength: null,
                maxLength: null,
            }),
        }).build({});
        const validator = value.validator;
        validator.unsafeCast({ a: [] });
        validator.unsafeCast({ a: ["a"] });
        expect(() => validator.unsafeCast({ a: ["4"] })).toThrowError();
        expect(() => validator.unsafeCast({ a: "4" })).toThrowError();
        (0, output_test_1.testOutput)()(null);
    });
});
//# sourceMappingURL=inputSpecBuilder.test.js.map