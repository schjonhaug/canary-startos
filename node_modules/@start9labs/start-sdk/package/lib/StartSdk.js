"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.StartSdk = exports.OSVersion = void 0;
exports.runCommand = runCommand;
const value_1 = require("../../base/lib/actions/input/builder/value");
const inputSpec_1 = require("../../base/lib/actions/input/builder/inputSpec");
const variants_1 = require("../../base/lib/actions/input/builder/variants");
const setupActions_1 = require("../../base/lib/actions/setupActions");
const patterns = __importStar(require("../../base/lib/util/patterns"));
const Backups_1 = require("./backup/Backups");
const inputSpecConstants_1 = require("../../base/lib/actions/input/inputSpecConstants");
const Daemons_1 = require("./mainFn/Daemons");
const checkPortListening_1 = require("./health/checkFns/checkPortListening");
const checkFns_1 = require("./health/checkFns");
const list_1 = require("../../base/lib/actions/input/builder/list");
const setupBackups_1 = require("./backup/setupBackups");
const mainFn_1 = require("./mainFn");
const defaultTrigger_1 = require("./trigger/defaultTrigger");
const trigger_1 = require("./trigger");
const setupInterfaces_1 = require("../../base/lib/interfaces/setupInterfaces");
const successFailure_1 = require("./trigger/successFailure");
const Host_1 = require("../../base/lib/interfaces/Host");
const ServiceInterfaceBuilder_1 = require("../../base/lib/interfaces/ServiceInterfaceBuilder");
const util_1 = require("./util");
const util_2 = require("./util");
const util_3 = require("./util");
const SubContainer_1 = require("./util/SubContainer");
const util_4 = require("./util");
const Mounts_1 = require("./mainFn/Mounts");
const setupDependencies_1 = require("../../base/lib/dependencies/setupDependencies");
const T = __importStar(require("../../base/lib/types"));
const exver_1 = require("../../base/lib/exver");
const dependencies_1 = require("../../base/lib/dependencies/dependencies");
const util_5 = require("./util");
const version_1 = require("./version");
const actions = __importStar(require("../../base/lib/actions"));
const fs = __importStar(require("node:fs/promises"));
const inits_1 = require("../../base/lib/inits");
const Drop_1 = require("../../base/lib/util/Drop");
exports.OSVersion = (0, exver_1.testTypeVersion)("0.4.0-alpha.14");
class StartSdk {
    constructor(manifest) {
        this.manifest = manifest;
    }
    static of() {
        return new StartSdk(null);
    }
    withManifest(manifest) {
        return new StartSdk(manifest);
    }
    build(isReady) {
        const startSdkEffectWrapper = {
            restart: (effects, ...args) => effects.restart(...args),
            setDependencies: (effects, ...args) => effects.setDependencies(...args),
            checkDependencies: (effects, ...args) => effects.checkDependencies(...args),
            mount: (effects, ...args) => effects.mount(...args),
            getInstalledPackages: (effects, ...args) => effects.getInstalledPackages(...args),
            getServicePortForward: (effects, ...args) => effects.getServicePortForward(...args),
            clearBindings: (effects, ...args) => effects.clearBindings(...args),
            getOsIp: (effects, ...args) => effects.getOsIp(...args),
            getSslKey: (effects, ...args) => effects.getSslKey(...args),
            shutdown: (effects, ...args) => effects.shutdown(...args),
            getDependencies: (effects, ...args) => effects.getDependencies(...args),
            getStatus: (effects, ...args) => effects.getStatus(...args),
            setHealth: (effects, ...args) => effects.setHealth(...args),
        };
        return {
            manifest: this.manifest,
            ...startSdkEffectWrapper,
            setDataVersion: version_1.setDataVersion,
            getDataVersion: version_1.getDataVersion,
            action: {
                run: actions.runAction,
                createTask: (effects, packageId, action, severity, options) => actions.createTask({
                    effects,
                    packageId,
                    action,
                    severity,
                    options: options,
                }),
                createOwnTask: (effects, action, severity, options) => actions.createTask({
                    effects,
                    packageId: this.manifest.id,
                    action,
                    severity,
                    options: options,
                }),
                clearTask: (effects, ...replayIds) => effects.action.clearTasks({ only: replayIds }),
            },
            checkDependencies: dependencies_1.checkDependencies,
            serviceInterface: {
                getOwn: (effects, id) => (0, util_3.getServiceInterface)(effects, {
                    id,
                }),
                get: (effects, opts) => (0, util_3.getServiceInterface)(effects, opts),
                getAllOwn: (effects) => (0, util_3.getServiceInterfaces)(effects, {}),
                getAll: (effects, opts) => (0, util_3.getServiceInterfaces)(effects, opts),
            },
            getContainerIp: (effects, options = {}) => {
                async function* watch(abort) {
                    const resolveCell = { resolve: () => { } };
                    effects.onLeaveContext(() => {
                        resolveCell.resolve();
                    });
                    abort?.addEventListener("abort", () => resolveCell.resolve());
                    while (effects.isInContext && !abort?.aborted) {
                        let callback = () => { };
                        const waitForNext = new Promise((resolve) => {
                            callback = resolve;
                            resolveCell.resolve = resolve;
                        });
                        yield await effects.getContainerIp({ ...options, callback });
                        await waitForNext;
                    }
                }
                return {
                    const: () => effects.getContainerIp({
                        ...options,
                        callback: effects.constRetry &&
                            (() => effects.constRetry && effects.constRetry()),
                    }),
                    once: () => effects.getContainerIp(options),
                    watch: (abort) => {
                        const ctrl = new AbortController();
                        abort?.addEventListener("abort", () => ctrl.abort());
                        return Drop_1.DropGenerator.of(watch(ctrl.signal), () => ctrl.abort());
                    },
                    onChange: (callback) => {
                        ;
                        (async () => {
                            const ctrl = new AbortController();
                            for await (const value of watch(ctrl.signal)) {
                                try {
                                    const res = await callback(value);
                                    if (res.cancel) {
                                        ctrl.abort();
                                        break;
                                    }
                                }
                                catch (e) {
                                    console.error("callback function threw an error @ getContainerIp.onChange", e);
                                }
                            }
                        })()
                            .catch((e) => callback(null, e))
                            .catch((e) => console.error("callback function threw an error @ getContainerIp.onChange", e));
                    },
                    waitFor: async (pred) => {
                        const resolveCell = { resolve: () => { } };
                        effects.onLeaveContext(() => {
                            resolveCell.resolve();
                        });
                        while (effects.isInContext) {
                            let callback = () => { };
                            const waitForNext = new Promise((resolve) => {
                                callback = resolve;
                                resolveCell.resolve = resolve;
                            });
                            const res = await effects.getContainerIp({ ...options, callback });
                            if (pred(res)) {
                                resolveCell.resolve();
                                return res;
                            }
                            await waitForNext;
                        }
                        return null;
                    },
                };
            },
            MultiHost: {
                of: (effects, id) => new Host_1.MultiHost({ id, effects }),
            },
            nullIfEmpty: util_2.nullIfEmpty,
            useEntrypoint: (overrideCmd) => new T.UseEntrypoint(overrideCmd),
            /**
             * @description Use this class to create an Action. By convention, each Action should receive its own file.
             *
             */
            Action: {
                /**
                 * @description Use this function to create an action that accepts form input
                 * @param id - a unique ID for this action
                 * @param metadata - information describing the action and its availability
                 * @param inputSpec - define the form input using the InputSpec and Value classes
                 * @param prefillFn - optionally fetch data from the file system to pre-fill the input form. Must returns a deep partial of the input spec
                 * @param executionFn - execute the action. Optionally return data for the user to view. Must be in the structure of an ActionResult, version "1"
                 * @example
                 * In this example, we create an action for a user to provide their name.
                 *   We prefill the input form with their existing name from the service's yaml file.
                 *   The new name is saved to the yaml file, and we return nothing to the user, which
                 *   means they will receive a generic success message.
                 *
                 * ```
                  import { sdk } from '../sdk'
                  import { yamlFile } from '../file-models/config.yml'
        
                  const { InputSpec, Value } = sdk
        
                  export const inputSpec = InputSpec.of({
                    name: Value.text({
                      name: 'Name',
                      description:
                        'When you launch the Hello World UI, it will display "Hello [Name]"',
                      required: true,
                      default: 'World',
                    }),
                  })
        
                  export const setName = sdk.Action.withInput(
                    // id
                    'set-name',
        
                    // metadata
                    async ({ effects }) => ({
                      name: 'Set Name',
                      description: 'Set your name so Hello World can say hello to you',
                      warning: null,
                      allowedStatuses: 'any',
                      group: null,
                      visibility: 'enabled',
                    }),
        
                    // form input specification
                    inputSpec,
        
                    // optionally pre-fill the input form
                    async ({ effects }) => {
                      const name = await yamlFile.read.const(effects)?.name
                      return { name }
                    },
        
                    // the execution function
                    async ({ effects, input }) => yamlFile.merge(input)
                  )
                 * ```
                */
                withInput: setupActions_1.Action.withInput,
                /**
                 * @description Use this function to create an action that does not accept form input
                 * @param id - a unique ID for this action
                 * @param metadata - information describing the action and its availability
                 * @param executionFn - execute the action. Optionally return data for the user to view. Must be in the structure of an ActionResult, version "1"
                 * @example
                 * In this example, we create an action that returns a secret phrase for the user to see.
                 *
                 * ```
                  import { store } from '../file-models/store.json'
                  import { sdk } from '../sdk'
        
                  export const showSecretPhrase = sdk.Action.withoutInput(
                    // id
                    'show-secret-phrase',
        
                    // metadata
                    async ({ effects }) => ({
                      name: 'Show Secret Phrase',
                      description: 'Reveal the secret phrase for Hello World',
                      warning: null,
                      allowedStatuses: 'any',
                      group: null,
                      visibility: 'enabled',
                    }),
        
                    // the execution function
                    async ({ effects }) => ({
                      version: '1',
                      title: 'Secret Phrase',
                      message:
                        'Below is your secret phrase. Use it to gain access to extraordinary places',
                      result: {
                        type: 'single',
                        value: (await store.read.once())?.secretPhrase,
                        copyable: true,
                        qr: true,
                        masked: true,
                      },
                    }),
                  )
                 * ```
                */
                withoutInput: (id, metadata, run) => setupActions_1.Action.withoutInput(id, metadata, run),
            },
            inputSpecConstants: { smtpInputSpec: inputSpecConstants_1.smtpInputSpec },
            /**
             * @description Use this function to create a service interface.
             * @param effects
             * @param options
             * @example
             * In this example, we create a standard web UI
             *
             * ```
              const ui = sdk.createInterface(effects, {
                name: 'Web UI',
                id: 'ui',
                description: 'The primary web app for this service.',
                type: 'ui',
                masked: false,
                schemeOverride: null,
                username: null,
                path: '',
                query: {},
              })
             * ```
             */
            createInterface: (effects, options) => new ServiceInterfaceBuilder_1.ServiceInterfaceBuilder({ ...options, effects }),
            getSystemSmtp: (effects) => new util_1.GetSystemSmtp(effects),
            getSslCerificate: (effects, hostnames, algorithm) => new util_5.GetSslCertificate(effects, hostnames, algorithm),
            healthCheck: {
                checkPortListening: checkPortListening_1.checkPortListening,
                checkWebUrl: checkFns_1.checkWebUrl,
                runHealthScript: checkFns_1.runHealthScript,
            },
            patterns,
            /**
             * @description Use this function to list every Action offered by the service. Actions will be displayed in the provided order.
             *
             *   By convention, each Action should receive its own file in the "actions" directory.
             * @example
             *
             * ```
              import { sdk } from '../sdk'
              import { config } from './config'
              import { nameToLogs } from './nameToLogs'
      
              export const actions = sdk.Actions.of().addAction(config).addAction(nameToLogs)
             * ```
             */
            Actions: (setupActions_1.Actions),
            /**
             * @description Use this function to determine which volumes are backed up when a user creates a backup, including advanced options.
             * @example
             * In this example, we back up the entire "main" volume and nothing else.
             *
             * ```
              import { sdk } from './sdk'
      
              export const { createBackup, restoreBackup } = sdk.setupBackups(
                async ({ effects }) => sdk.Backups.volumes('main'),
              )
             * ```
             * @example
             * In this example, we back up the "main" volume, but exclude hypothetical directory "excludedDir".
             *
             * ```
              import { sdk } from './sdk'
      
              export const { createBackup, restoreBackup } = sdk.setupBackups(async () =>
                sdk.Backups.volumes('main').setOptions({
                  exclude: ['excludedDir'],
                }),
              )
             * ```
             */
            setupBackups: (options) => (0, setupBackups_1.setupBackups)(options),
            /**
             * @description Use this function to set dependency information.
             * @example
             * In this example, we create a dependency on Hello World >=1.0.0:0, where Hello World must be running and passing its "primary" health check.
             *
             * ```
              export const setDependencies = sdk.setupDependencies(
                async ({ effects }) => {
                  return {
                    'hello-world': {
                      kind: 'running',
                      versionRange: '>=1.0.0',
                      healthChecks: ['primary'],
                    },
                  }
                },
              )
             * ```
             */
            setupDependencies: (setupDependencies_1.setupDependencies),
            /**
             * @description Use this function to create an InitScript that runs every time the service initializes (install, update, restore, rebuild, and server bootup)
             */
            setupOnInit: inits_1.setupOnInit,
            /**
             * @description Use this function to create an UninitScript that runs every time the service uninitializes (update, uninstall, and server shutdown)
             */
            setupOnUninit: inits_1.setupOnUninit,
            /**
             * @description Use this function to setup what happens when the service initializes.
             *
             *    This happens when the server boots, or a service is installed, updated, or restored
             *
             *    Not every init script does something on every initialization. For example, versions only does something on install or update
             *
             *    These scripts are run in the order they are supplied
             * @example
             *
             * ```
              export const init = sdk.setupInit(
                restoreInit,
                versions,
                setDependencies,
                setInterfaces,
                actions,
                postInstall,
              )
             * ```
             */
            setupInit: inits_1.setupInit,
            /**
             * @description Use this function to setup what happens when the service uninitializes.
             *
             *    This happens when the server shuts down, or a service is uninstalled or updated
             *
             *    Not every uninit script does something on every uninitialization. For example, versions only does something on uninstall or update
             *
             *    These scripts are run in the order they are supplied
             * @example
             *
             * ```
              export const uninit = sdk.setupUninit(
                versions,
              )
             * ```
             */
            setupUninit: inits_1.setupUninit,
            /**
             * @description Use this function to determine how this service will be hosted and served. The function executes on service install, service update, and inputSpec save.
             * @param inputSpec - The inputSpec spec of this service as exported from /inputSpec/spec.
             * @param fn - an async function that returns an array of interface receipts. The function always has access to `effects`; it has access to `input` only after inputSpec save, otherwise `input` will be null.
             * @example
             * In this example, we create two UIs from one multi-host, and one API from another multi-host.
             *
             * ```
              export const setInterfaces = sdk.setupInterfaces(
                async ({ effects }) => {
                  // ** UI multi-host **
                  const uiMulti = sdk.MultiHost.of(effects, 'ui-multi')
                  const uiMultiOrigin = await uiMulti.bindPort(80, {
                    protocol: 'http',
                  })
                  // Primary UI
                  const primaryUi = sdk.createInterface(effects, {
                    name: 'Primary UI',
                    id: 'primary-ui',
                    description: 'The primary web app for this service.',
                    type: 'ui',
                    masked: false,
                    schemeOverride: null,
                    username: null,
                    path: '',
                    query: {},
                  })
                  // Admin UI
                  const adminUi = sdk.createInterface(effects, {
                    name: 'Admin UI',
                    id: 'admin-ui',
                    description: 'The admin web app for this service.',
                    type: 'ui',
                    masked: false,
                    schemeOverride: null,
                    username: null,
                    path: '/admin',
                    query: {},
                  })
                  // UI receipt
                  const uiReceipt = await uiMultiOrigin.export([primaryUi, adminUi])
             
                  // ** API multi-host **
                  const apiMulti = sdk.MultiHost.of(effects, 'api-multi')
                  const apiMultiOrigin = await apiMulti.bindPort(5959, {
                    protocol: 'http',
                  })
                  // API
                  const api = sdk.createInterface(effects, {
                    name: 'Admin API',
                    id: 'api',
                    description: 'The advanced API for this service.',
                    type: 'api',
                    masked: false,
                    schemeOverride: null,
                    username: null,
                    path: '',
                    query: {},
                  })
                  // API receipt
                  const apiReceipt = await apiMultiOrigin.export([api])
             
                  // ** Return receipts **
                  return [uiReceipt, apiReceipt]
                },
              )
             * ```
             */
            setupInterfaces: setupInterfaces_1.setupServiceInterfaces,
            setupMain: (fn) => (0, mainFn_1.setupMain)(fn),
            trigger: {
                defaultTrigger: defaultTrigger_1.defaultTrigger,
                cooldownTrigger: trigger_1.cooldownTrigger,
                changeOnFirstSuccess: trigger_1.changeOnFirstSuccess,
                successFailure: successFailure_1.successFailure,
            },
            Mounts: {
                of: (Mounts_1.Mounts.of),
            },
            Backups: {
                ofVolumes: (Backups_1.Backups.ofVolumes),
                ofSyncs: (Backups_1.Backups.ofSyncs),
                withOptions: (Backups_1.Backups.withOptions),
            },
            InputSpec: {
                /**
                 * @description Use this function to define the inputSpec specification that will ultimately present to the user as validated form inputs.
                 *
                 *   Most form controls are supported, including text, textarea, number, toggle, select, multiselect, list, color, datetime, object (sub form), and union (conditional sub form).
                 * @example
                 * In this example, we define a inputSpec form with two value: name and makePublic.
                 *
                 * ```
                  import { sdk } from '../sdk'
                  const { InputSpec, Value } = sdk
                 
                  export const inputSpecSpec = InputSpec.of({
                    name: Value.text({
                      name: 'Name',
                      description:
                        'When you launch the Hello World UI, it will display "Hello [Name]"',
                      required: true,
                      default: 'World'
                    }),
                    makePublic: Value.toggle({
                      name: 'Make Public',
                      description: 'Whether or not to expose the service to the network',
                      default: false,
                    }),
                  })
                 * ```
                 */
                of: (spec) => inputSpec_1.InputSpec.of(spec),
            },
            Daemon: {
                get of() {
                    return Daemons_1.Daemon.of();
                },
            },
            Daemons: {
                of(effects, started) {
                    return Daemons_1.Daemons.of({ effects, started });
                },
            },
            SubContainer: {
                /**
                 * @description Create a new SubContainer
                 * @param effects
                 * @param image - what container image to use
                 * @param mounts - what to mount to the subcontainer
                 * @param name - a name to use to refer to the subcontainer for debugging purposes
                 */
                of(effects, image, mounts, name) {
                    return SubContainer_1.SubContainerOwned.of(effects, image, mounts, name).then((subc) => subc.rc());
                },
                /**
                 * @description Run a function with a temporary SubContainer
                 * @param effects
                 * @param image - what container image to use
                 * @param mounts - what to mount to the subcontainer
                 * @param name - a name to use to refer to the ephemeral subcontainer for debugging purposes
                 */
                withTemp(effects, image, mounts, name, fn) {
                    return SubContainer_1.SubContainerOwned.withTemp(effects, image, mounts, name, fn);
                },
            },
            List: list_1.List,
            Value: value_1.Value,
            Variants: variants_1.Variants,
        };
    }
}
exports.StartSdk = StartSdk;
async function runCommand(effects, image, command, options, name) {
    let commands;
    if (T.isUseEntrypoint(command)) {
        const imageMeta = await fs
            .readFile(`/media/startos/images/${image.imageId}.json`, {
            encoding: "utf8",
        })
            .catch(() => "{}")
            .then(JSON.parse);
        commands = imageMeta.entrypoint ?? [];
        commands = commands.concat(...(command.overridCmd ?? imageMeta.cmd ?? []));
    }
    else
        commands = (0, util_4.splitCommand)(command);
    return SubContainer_1.SubContainerOwned.withTemp(effects, image, options.mounts, name ||
        commands
            .map((c) => {
            if (c.includes(" ")) {
                return `"${c.replace(/"/g, `\"`)}"`;
            }
            else {
                return c;
            }
        })
            .join(" "), async (subcontainer) => {
        const res = await subcontainer.exec(commands);
        if (res.exitCode || res.exitSignal) {
            throw new SubContainer_1.ExitError(commands[0], res);
        }
        else {
            return res;
        }
    });
}
//# sourceMappingURL=StartSdk.js.map