"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileHelper = void 0;
const matches = __importStar(require("ts-matches"));
const YAML = __importStar(require("yaml"));
const TOML = __importStar(require("@iarna/toml"));
const INI = __importStar(require("ini"));
const fs = __importStar(require("node:fs/promises"));
const util_1 = require("../../../base/lib/util");
const Drop_1 = require("../../../base/lib/util/Drop");
const previousPath = /(.+?)\/([^/]*)$/;
const deepEq = (left, right) => {
    if (left === right)
        return true;
    if (Array.isArray(left) && Array.isArray(right)) {
        if (left.length === right.length) {
            for (const idx in left) {
                if (!deepEq(left[idx], right[idx]))
                    return false;
            }
            return true;
        }
    }
    else if (typeof left === "object" &&
        typeof right === "object" &&
        left &&
        right) {
        const keys = new Set([
            ...Object.keys(left),
            ...Object.keys(right),
        ]);
        for (let key of keys) {
            if (!deepEq(left[key], right[key]))
                return false;
        }
        return true;
    }
    return false;
};
const exists = (path) => fs.access(path).then(() => true, () => false);
async function onCreated(path) {
    if (path === "/")
        return;
    if (!path.startsWith("/"))
        path = `${process.cwd()}/${path}`;
    if (await exists(path)) {
        return;
    }
    const split = path.split("/");
    const filename = split.pop();
    const parent = split.join("/");
    await onCreated(parent);
    const ctrl = new AbortController();
    const watch = fs.watch(parent, { persistent: false, signal: ctrl.signal });
    if (await exists(path)) {
        ctrl.abort();
        return;
    }
    if (await fs.access(path).then(() => true, () => false)) {
        ctrl.abort();
        return;
    }
    for await (let event of watch) {
        if (event.filename === filename) {
            ctrl.abort("finished");
            return;
        }
    }
}
function fileMerge(...args) {
    let res = args.shift();
    for (const arg of args) {
        if (res === arg)
            continue;
        else if (res &&
            arg &&
            typeof res === "object" &&
            typeof arg === "object" &&
            !Array.isArray(res) &&
            !Array.isArray(arg)) {
            for (const key of Object.keys(arg)) {
                res[key] = fileMerge(res[key], arg[key]);
            }
        }
        else
            res = arg;
    }
    return res;
}
function filterUndefined(a) {
    if (a && typeof a === "object") {
        if (Array.isArray(a)) {
            return a.map(filterUndefined);
        }
        return Object.entries(a).reduce((acc, [k, v]) => {
            if (v !== undefined) {
                acc[k] = filterUndefined(v);
            }
            return acc;
        }, {});
    }
    return a;
}
function toPath(path) {
    return typeof path === "string"
        ? path
        : `/media/startos/volumes/${path.volumeId}/${path.subpath}`;
}
/**
 * @description Use this class to read/write an underlying configuration file belonging to the upstream service.
 *
 *   These type definitions should reflect the underlying file as closely as possible. For example, if the service does not require a particular value, it should be marked as optional(), even if your package requires it.
 *
 *   It is recommended to use onMismatch() whenever possible. This provides an escape hatch in case the user edits the file manually and accidentally sets a value to an unsupported type.
 *
 *   Officially supported file types are json, yaml, and toml. Other files types can use "raw"
 *
 *   Choose between officially supported file formats (), or a custom format (raw).
 *
 * @example
 * Below are a few examples
 *
 * ```
 * import { matches, FileHelper } from '@start9labs/start-sdk'
 * const { arrayOf, boolean, literal, literals, object, natural, string } = matches
 *
 * export const jsonFile = FileHelper.json('./inputSpec.json', object({
 *   passwords: arrayOf(string).onMismatch([])
 *   type: literals('private', 'public').optional().onMismatch(undefined)
 * }))
 *
 * export const tomlFile = FileHelper.toml('./inputSpec.toml', object({
 *   url: literal('https://start9.com').onMismatch('https://start9.com')
 *   public: boolean.onMismatch(true)
 * }))
 *
 * export const yamlFile = FileHelper.yaml('./inputSpec.yml', object({
 *   name: string.optional().onMismatch(undefined)
 *   age: natural.optional().onMismatch(undefined)
 * }))
 *
 * export const bitcoinConfFile = FileHelper.raw(
 *   './service.conf',
 *   (obj: CustomType) => customConvertObjToFormattedString(obj),
 *   (str) => customParseStringToTypedObj(str),
 * )
 * ```
 */
class FileHelper {
    constructor(path, writeData, readData, validate) {
        this.path = path;
        this.writeData = writeData;
        this.readData = readData;
        this.validate = validate;
        this.consts = [];
    }
    async writeFileRaw(data) {
        const parent = previousPath.exec(this.path);
        if (parent) {
            await fs.mkdir(parent[1], { recursive: true });
        }
        await fs.writeFile(this.path, data);
        return null;
    }
    /**
     * Accepts structured data and overwrites the existing file on disk.
     */
    async writeFile(data) {
        return await this.writeFileRaw(this.writeData(data));
    }
    async readFileRaw() {
        if (!(await exists(this.path))) {
            return null;
        }
        return await fs.readFile(this.path).then((data) => data.toString("utf-8"));
    }
    async readFile() {
        const raw = await this.readFileRaw();
        if (raw === null) {
            return raw;
        }
        return this.readData(raw);
    }
    /**
     * Reads the file from disk and converts it to structured data.
     */
    async readOnce(map) {
        const data = await this.readFile();
        if (!data)
            return null;
        return map(this.validate(data));
    }
    async readConst(effects, map, eq) {
        const watch = this.readWatch(effects, map, eq);
        const res = await watch.next();
        if (effects.constRetry) {
            const record = [
                effects.constRetry,
                res.value,
                map,
                eq,
            ];
            this.consts.push(record);
            watch.next().then(() => {
                this.consts = this.consts.filter((r) => r !== record);
                effects.constRetry && effects.constRetry();
            });
        }
        return res.value;
    }
    async *readWatch(effects, map, eq, abort) {
        let prev = null;
        while (effects.isInContext && !abort?.aborted) {
            if (await exists(this.path)) {
                const ctrl = new AbortController();
                abort?.addEventListener("abort", () => ctrl.abort());
                const watch = fs.watch(this.path, {
                    persistent: false,
                    signal: ctrl.signal,
                });
                const newRes = await this.readOnce(map);
                const listen = Promise.resolve()
                    .then(async () => {
                    for await (const _ of watch) {
                        ctrl.abort();
                        return null;
                    }
                })
                    .catch((e) => console.error((0, util_1.asError)(e)));
                if (!prev || !eq(prev.value, newRes)) {
                    yield newRes;
                }
                prev = { value: newRes };
                await listen;
            }
            else {
                yield null;
                await onCreated(this.path).catch((e) => console.error((0, util_1.asError)(e)));
            }
        }
        return null;
    }
    readOnChange(effects, callback, map, eq) {
        ;
        (async () => {
            const ctrl = new AbortController();
            for await (const value of this.readWatch(effects, map, eq, ctrl.signal)) {
                try {
                    const res = await callback(value);
                    if (res.cancel)
                        ctrl.abort();
                }
                catch (e) {
                    console.error("callback function threw an error @ FileHelper.read.onChange", e);
                }
            }
        })()
            .catch((e) => callback(null, e))
            .catch((e) => console.error("callback function threw an error @ FileHelper.read.onChange", e));
    }
    readWaitFor(effects, pred, map) {
        const ctrl = new AbortController();
        return Drop_1.DropPromise.of(Promise.resolve().then(async () => {
            const watch = this.readWatch(effects, map, (_) => false, ctrl.signal);
            while (true) {
                try {
                    const res = await watch.next();
                    if (pred(res.value)) {
                        ctrl.abort();
                        return res.value;
                    }
                    if (res.done) {
                        break;
                    }
                }
                catch (e) {
                    if (pred(null, e)) {
                        break;
                    }
                }
            }
            ctrl.abort();
            return null;
        }), () => ctrl.abort());
    }
    read(map, eq) {
        map = map ?? ((a) => a);
        eq = eq ?? deepEq;
        return {
            once: () => this.readOnce(map),
            const: (effects) => this.readConst(effects, map, eq),
            watch: (effects, abort) => {
                const ctrl = new AbortController();
                abort?.addEventListener("abort", () => ctrl.abort());
                return Drop_1.DropGenerator.of(this.readWatch(effects, map, eq, ctrl.signal), () => ctrl.abort());
            },
            onChange: (effects, callback) => this.readOnChange(effects, callback, map, eq),
            waitFor: (effects, pred) => this.readWaitFor(effects, pred, map),
        };
    }
    /**
     * Accepts full structured data and overwrites the existing file on disk if it exists.
     */
    async write(effects, data, options = {}) {
        const newData = this.validate(data);
        await this.writeFile(newData);
        if (!options.allowWriteAfterConst && effects.constRetry) {
            const records = this.consts.filter(([c]) => c === effects.constRetry);
            for (const record of records) {
                const [_, prev, map, eq] = record;
                if (!eq(prev, map(newData))) {
                    throw new Error(`Canceled: write after const: ${this.path}`);
                }
            }
        }
        return null;
    }
    /**
     * Accepts partial structured data and performs a merge with the existing file on disk.
     */
    async merge(effects, data, options = {}) {
        const fileDataRaw = await this.readFileRaw();
        let fileData = fileDataRaw === null ? null : this.readData(fileDataRaw);
        try {
            fileData = this.validate(fileData);
        }
        catch (_) { }
        const mergeData = this.validate(fileMerge({}, fileData, data));
        const toWrite = this.writeData(mergeData);
        if (toWrite !== fileDataRaw) {
            this.writeFile(mergeData);
            if (!options.allowWriteAfterConst && effects.constRetry) {
                const records = this.consts.filter(([c]) => c === effects.constRetry);
                for (const record of records) {
                    const [_, prev, map, eq] = record;
                    if (!eq(prev, map(mergeData))) {
                        throw new Error(`Canceled: write after const: ${this.path}`);
                    }
                }
            }
        }
        return null;
    }
    /**
     * We wanted to be able to have a fileHelper, and just modify the path later in time.
     * Like one behavior of another dependency or something similar.
     */
    withPath(path) {
        return new FileHelper(toPath(path), this.writeData, this.readData, this.validate);
    }
    /**
     * Create a File Helper for an arbitrary file type.
     *
     * Provide custom functions for translating data to/from the file format.
     */
    static raw(path, toFile, fromFile, validate) {
        return new FileHelper(toPath(path), toFile, fromFile, validate);
    }
    static rawTransformed(path, toFile, fromFile, validate, transformers) {
        return FileHelper.raw(path, (inData) => {
            if (transformers) {
                return toFile(transformers.onWrite(inData));
            }
            return toFile(inData);
        }, fromFile, validate);
    }
    static string(path, shape, transformers) {
        return FileHelper.rawTransformed(path, (inData) => inData, (inString) => inString, (data) => (shape || matches.string).unsafeCast(data), transformers);
    }
    /**
     * Create a File Helper for a .json file.
     */
    static json(path, shape, transformers) {
        return FileHelper.rawTransformed(path, (inData) => JSON.stringify(inData, null, 2), (inString) => JSON.parse(inString), (data) => shape.unsafeCast(data), transformers);
    }
    static yaml(path, shape, transformers) {
        return FileHelper.rawTransformed(path, (inData) => YAML.stringify(inData, null, 2), (inString) => YAML.parse(inString), (data) => shape.unsafeCast(data), transformers);
    }
    static toml(path, shape, transformers) {
        return FileHelper.rawTransformed(path, (inData) => TOML.stringify(inData), (inString) => TOML.parse(inString), (data) => shape.unsafeCast(data), transformers);
    }
    static ini(path, shape, options, transformers) {
        return FileHelper.rawTransformed(path, (inData) => INI.stringify(filterUndefined(inData), options), (inString) => INI.parse(inString, options), (data) => shape.unsafeCast(data), transformers);
    }
    static env(path, shape, transformers) {
        return FileHelper.rawTransformed(path, (inData) => Object.entries(inData)
            .map(([k, v]) => `${k}=${v}`)
            .join("\n"), (inString) => Object.fromEntries(inString
            .split("\n")
            .map((line) => line.trim())
            .filter((line) => !line.startsWith("#") && line.includes("="))
            .map((line) => line.split("=", 2))), (data) => shape.unsafeCast(data), transformers);
    }
}
exports.FileHelper = FileHelper;
exports.default = FileHelper;
//# sourceMappingURL=fileHelper.js.map