import * as T from "../../../base/lib/types";
import * as cp from "child_process";
import { Buffer } from "node:buffer";
import { Drop } from "../../../base/lib/util/Drop";
import { Mounts } from "../mainFn/Mounts";
import { BackupEffects } from "../backup/Backups";
export declare const execFile: typeof cp.execFile.__promisify__;
export type ExecOptions = {
    input?: string | Buffer;
};
export interface SubContainer<Manifest extends T.SDKManifest, Effects extends T.Effects = T.Effects> extends Drop {
    readonly imageId: keyof Manifest["images"] & T.ImageId;
    readonly rootfs: string;
    readonly guid: T.Guid;
    mount(mounts: Effects extends BackupEffects ? Mounts<Manifest, {
        subpath: string | null;
        mountpoint: string;
    }> : Mounts<Manifest, never>): Promise<this>;
    destroy: () => Promise<null>;
    /**
     * @description run a command inside this subcontainer
     * DOES NOT THROW ON NONZERO EXIT CODE (see execFail)
     * @param commands an array representing the command and args to execute
     * @param options
     * @param timeoutMs how long to wait before killing the command in ms
     * @returns
     */
    exec(command: string[], options?: CommandOptions & ExecOptions, timeoutMs?: number | null, abort?: AbortController): Promise<{
        throw: () => {
            stdout: string | Buffer;
            stderr: string | Buffer;
        };
        exitCode: number | null;
        exitSignal: NodeJS.Signals | null;
        stdout: string | Buffer;
        stderr: string | Buffer;
    }>;
    /**
     * @description run a command inside this subcontainer, throwing on non-zero exit status
     * @param commands an array representing the command and args to execute
     * @param options
     * @param timeoutMs how long to wait before killing the command in ms
     * @returns
     */
    execFail(command: string[], options?: CommandOptions & ExecOptions, timeoutMs?: number | null, abort?: AbortController): Promise<{
        stdout: string | Buffer;
        stderr: string | Buffer;
    }>;
    launch(command: string[], options?: CommandOptions): Promise<cp.ChildProcessWithoutNullStreams>;
    spawn(command: string[], options?: CommandOptions & StdioOptions): Promise<cp.ChildProcess>;
    rc(): SubContainerRc<Manifest, Effects>;
    isOwned(): this is SubContainerOwned<Manifest, Effects>;
}
/**
 * Want to limit what we can do in a container, so we want to launch a container with a specific image and the mounts.
 */
export declare class SubContainerOwned<Manifest extends T.SDKManifest, Effects extends T.Effects = T.Effects> extends Drop implements SubContainer<Manifest, Effects> {
    readonly effects: Effects;
    readonly imageId: keyof Manifest["images"] & T.ImageId;
    readonly rootfs: string;
    readonly guid: T.Guid;
    private destroyed;
    rcs: number;
    private leader;
    private leaderExited;
    private waitProc;
    private constructor();
    static of<Manifest extends T.SDKManifest, Effects extends T.Effects>(effects: Effects, image: {
        imageId: keyof Manifest["images"] & T.ImageId;
        sharedRun?: boolean;
    }, mounts: (Effects extends BackupEffects ? Mounts<Manifest, {
        subpath: string | null;
        mountpoint: string;
    }> : Mounts<Manifest, never>) | null, name: string): Promise<SubContainerOwned<Manifest, Effects>>;
    static withTemp<Manifest extends T.SDKManifest, T, Effects extends T.Effects>(effects: Effects, image: {
        imageId: keyof Manifest["images"] & T.ImageId;
        sharedRun?: boolean;
    }, mounts: (Effects extends BackupEffects ? Mounts<Manifest, {
        subpath: string | null;
        mountpoint: string;
    }> : Mounts<Manifest, never>) | null, name: string, fn: (subContainer: SubContainer<Manifest, Effects>) => Promise<T>): Promise<T>;
    mount(mounts: Effects extends BackupEffects ? Mounts<Manifest, {
        subpath: string | null;
        mountpoint: string;
    }> : Mounts<Manifest, never>): Promise<this>;
    private killLeader;
    get destroy(): () => Promise<null>;
    onDrop(): void;
    /**
     * @description run a command inside this subcontainer
     * DOES NOT THROW ON NONZERO EXIT CODE (see execFail)
     * @param commands an array representing the command and args to execute
     * @param options
     * @param timeoutMs how long to wait before killing the command in ms
     * @returns
     */
    exec(command: string[], options?: CommandOptions & ExecOptions, timeoutMs?: number | null, abort?: AbortController): Promise<{
        throw: () => {
            stdout: string | Buffer;
            stderr: string | Buffer;
        };
        exitCode: number | null;
        exitSignal: NodeJS.Signals | null;
        stdout: string | Buffer;
        stderr: string | Buffer;
    }>;
    /**
     * @description run a command inside this subcontainer, throwing on non-zero exit status
     * @param commands an array representing the command and args to execute
     * @param options
     * @param timeoutMs how long to wait before killing the command in ms
     * @returns
     */
    execFail(command: string[], options?: CommandOptions & ExecOptions, timeoutMs?: number | null, abort?: AbortController): Promise<{
        stdout: string | Buffer;
        stderr: string | Buffer;
    }>;
    launch(command: string[], options?: CommandOptions): Promise<cp.ChildProcessWithoutNullStreams>;
    spawn(command: string[], options?: CommandOptions & StdioOptions): Promise<cp.ChildProcess>;
    rc(): SubContainerRc<Manifest, Effects>;
    isOwned(): this is SubContainerOwned<Manifest, Effects>;
}
export declare class SubContainerRc<Manifest extends T.SDKManifest, Effects extends T.Effects = T.Effects> extends Drop implements SubContainer<Manifest, Effects> {
    private readonly subcontainer;
    get imageId(): keyof Manifest["images"] & string;
    get rootfs(): string;
    get guid(): string;
    private destroyed;
    private destroying;
    constructor(subcontainer: SubContainerOwned<Manifest, Effects>);
    static of<Manifest extends T.SDKManifest, Effects extends T.Effects>(effects: Effects, image: {
        imageId: keyof Manifest["images"] & T.ImageId;
        sharedRun?: boolean;
    }, mounts: (Effects extends BackupEffects ? Mounts<Manifest, {
        subpath: string | null;
        mountpoint: string;
    }> : Mounts<Manifest, never>) | null, name: string): Promise<SubContainerRc<Manifest, Effects>>;
    static withTemp<Manifest extends T.SDKManifest, T, Effects extends T.Effects>(effects: Effects, image: {
        imageId: keyof Manifest["images"] & T.ImageId;
        sharedRun?: boolean;
    }, mounts: (Effects extends BackupEffects ? Mounts<Manifest, {
        subpath: string | null;
        mountpoint: string;
    }> : Mounts<Manifest, never>) | null, name: string, fn: (subContainer: SubContainer<Manifest, Effects>) => Promise<T>): Promise<T>;
    mount(mounts: Effects extends BackupEffects ? Mounts<Manifest, {
        subpath: string | null;
        mountpoint: string;
    }> : Mounts<Manifest, never>): Promise<this>;
    get destroy(): () => Promise<null>;
    onDrop(): void;
    /**
     * @description run a command inside this subcontainer
     * DOES NOT THROW ON NONZERO EXIT CODE (see execFail)
     * @param commands an array representing the command and args to execute
     * @param options
     * @param timeoutMs how long to wait before killing the command in ms
     * @returns
     */
    exec(command: string[], options?: CommandOptions & ExecOptions, timeoutMs?: number | null, abort?: AbortController): Promise<{
        throw: () => {
            stdout: string | Buffer;
            stderr: string | Buffer;
        };
        exitCode: number | null;
        exitSignal: NodeJS.Signals | null;
        stdout: string | Buffer;
        stderr: string | Buffer;
    }>;
    /**
     * @description run a command inside this subcontainer, throwing on non-zero exit status
     * @param commands an array representing the command and args to execute
     * @param options
     * @param timeoutMs how long to wait before killing the command in ms
     * @returns
     */
    execFail(command: string[], options?: CommandOptions & ExecOptions, timeoutMs?: number | null, abort?: AbortController): Promise<{
        stdout: string | Buffer;
        stderr: string | Buffer;
    }>;
    launch(command: string[], options?: CommandOptions): Promise<cp.ChildProcessWithoutNullStreams>;
    spawn(command: string[], options?: CommandOptions & StdioOptions): Promise<cp.ChildProcess>;
    rc(): SubContainerRc<Manifest, Effects>;
    isOwned(): this is SubContainerOwned<Manifest, Effects>;
}
export type CommandOptions = {
    /**
     * Environment variables to set for this command
     */
    env?: {
        [variable: string]: string;
    };
    /**
     * the working directory to run this command in
     */
    cwd?: string;
    /**
     * the user to run this command as
     */
    user?: string;
};
export type StdioOptions = {
    stdio?: cp.IOType;
};
export type MountOptions = MountOptionsVolume | MountOptionsAssets | MountOptionsPointer | MountOptionsBackup;
export type MountOptionsVolume = {
    type: "volume";
    volumeId: string;
    subpath: string | null;
    readonly: boolean;
    filetype: "file" | "directory" | "infer";
};
export type MountOptionsAssets = {
    type: "assets";
    subpath: string | null;
    filetype: "file" | "directory" | "infer";
};
export type MountOptionsPointer = {
    type: "pointer";
    packageId: string;
    volumeId: string;
    subpath: string | null;
    readonly: boolean;
    filetype: "file" | "directory" | "infer";
};
export type MountOptionsBackup = {
    type: "backup";
    subpath: string | null;
    filetype: "file" | "directory" | "infer";
};
export declare class ExitError extends Error {
    readonly command: string;
    readonly result: {
        exitCode: number | null;
        exitSignal: T.Signals | null;
        stdout: string | Buffer;
        stderr: string | Buffer;
    };
    constructor(command: string, result: {
        exitCode: number | null;
        exitSignal: T.Signals | null;
        stdout: string | Buffer;
        stderr: string | Buffer;
    });
}
