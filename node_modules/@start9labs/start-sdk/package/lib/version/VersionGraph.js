"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VersionGraph = void 0;
exports.getDataVersion = getDataVersion;
exports.setDataVersion = setDataVersion;
exports.overlaps = overlaps;
const exver_1 = require("../../../base/lib/exver");
const util_1 = require("../util");
const VersionInfo_1 = require("./VersionInfo");
async function getDataVersion(effects) {
    const versionStr = await effects.getDataVersion();
    if (!versionStr)
        return null;
    try {
        return exver_1.ExtendedVersion.parse(versionStr);
    }
    catch (_) {
        return exver_1.VersionRange.parse(versionStr);
    }
}
async function setDataVersion(effects, version) {
    return effects.setDataVersion({ version: version?.toString() || null });
}
function isExver(v) {
    return "satisfies" in v;
}
function isRange(v) {
    return "satisfiedBy" in v;
}
function overlaps(a, b) {
    return ((isRange(a) && isRange(b) && a.intersects(b)) ||
        (isRange(a) && isExver(b) && a.satisfiedBy(b)) ||
        (isExver(a) && isRange(b) && a.satisfies(b)) ||
        (isExver(a) && isExver(b) && a.equals(b)));
}
class VersionGraph {
    dump() {
        return this.graph().dump((metadata) => metadata?.toString());
    }
    constructor(current, versions, preInstall, uninstall) {
        this.current = current;
        this.preInstall = preInstall;
        this.uninstall = uninstall;
        this.initFn = this.init.bind(this);
        this.uninitFn = this.uninit.bind(this);
        this.currentVersion = (0, util_1.once)(() => exver_1.ExtendedVersion.parse(this.current.options.version));
        this.canMigrateFrom = (0, util_1.once)(() => Array.from(this.graph().reverseBreadthFirstSearch((v) => overlaps(v.metadata, this.currentVersion())))
            .reduce((acc, x) => acc.or(isRange(x.metadata)
            ? x.metadata
            : exver_1.VersionRange.anchor("=", x.metadata)), exver_1.VersionRange.none())
            .normalize());
        this.canMigrateTo = (0, util_1.once)(() => Array.from(this.graph().breadthFirstSearch((v) => overlaps(v.metadata, this.currentVersion())))
            .reduce((acc, x) => acc.or(isRange(x.metadata)
            ? x.metadata
            : exver_1.VersionRange.anchor("=", x.metadata)), exver_1.VersionRange.none())
            .normalize());
        this.graph = (0, util_1.once)(() => {
            const graph = new util_1.Graph();
            const flavorMap = {};
            for (let version of [current, ...versions]) {
                const v = exver_1.ExtendedVersion.parse(version.options.version);
                const vertex = graph.addVertex(v, [], []);
                const flavor = v.flavor || "";
                if (!flavorMap[flavor]) {
                    flavorMap[flavor] = [];
                }
                flavorMap[flavor].push([v, version, vertex]);
            }
            for (let flavor in flavorMap) {
                flavorMap[flavor].sort((a, b) => a[0].compareForSort(b[0]));
                let prev = undefined;
                for (let [v, version, vertex] of flavorMap[flavor]) {
                    if (version.options.migrations.up !== VersionInfo_1.IMPOSSIBLE) {
                        let range;
                        if (prev) {
                            graph.addEdge(version.options.migrations.up, prev[2], vertex);
                            range = exver_1.VersionRange.anchor(">=", prev[0]).and(exver_1.VersionRange.anchor("<", v));
                        }
                        else {
                            range = exver_1.VersionRange.anchor("<", v);
                        }
                        const vRange = graph.addVertex(range, [], []);
                        graph.addEdge(version.options.migrations.up, vRange, vertex);
                    }
                    if (version.options.migrations.down !== VersionInfo_1.IMPOSSIBLE) {
                        let range;
                        if (prev) {
                            graph.addEdge(version.options.migrations.down, vertex, prev[2]);
                            range = exver_1.VersionRange.anchor(">=", prev[0]).and(exver_1.VersionRange.anchor("<", v));
                        }
                        else {
                            range = exver_1.VersionRange.anchor("<", v);
                        }
                        const vRange = graph.addVertex(range, [], []);
                        graph.addEdge(version.options.migrations.down, vertex, vRange);
                    }
                    if (version.options.migrations.other) {
                        for (let rangeStr in version.options.migrations.other) {
                            const range = exver_1.VersionRange.parse(rangeStr);
                            const vRange = graph.addVertex(range, [], []);
                            const migration = version.options.migrations.other[rangeStr];
                            if (migration.up)
                                graph.addEdge(migration.up, vRange, vertex);
                            if (migration.down)
                                graph.addEdge(migration.down, vertex, vRange);
                            for (let matching of graph.findVertex((v) => isExver(v.metadata) && v.metadata.satisfies(range))) {
                                if (migration.up)
                                    graph.addEdge(migration.up, matching, vertex);
                                if (migration.down)
                                    graph.addEdge(migration.down, vertex, matching);
                            }
                        }
                    }
                    prev = [v, version, vertex];
                }
            }
            return graph;
        });
    }
    /**
     * Each exported `VersionInfo.of()` should be imported and provided as an argument to this function.
     *
     * ** The current version must be the FIRST argument. **
     */
    static of(options) {
        return new VersionGraph(options.current, options.other, options.preInstall, options.uninstall);
    }
    async migrate({ effects, from, to, }) {
        if (overlaps(from, to))
            return from;
        const graph = this.graph();
        if (from && to) {
            const path = graph.shortestPath((v) => overlaps(v.metadata, from), (v) => overlaps(v.metadata, to));
            if (path) {
                console.log(`Migrating ${path.reduce(({ acc, prev }, x) => ({
                    acc: acc +
                        (prev && prev != x.from.metadata.toString()
                            ? ` (as ${prev})`
                            : "") +
                        " -> " +
                        x.to.metadata.toString(),
                    prev: x.to.metadata.toString(),
                }), { acc: from.toString(), prev: null }).acc}`);
                let dataVersion = from;
                for (let edge of path) {
                    if (edge.metadata) {
                        await edge.metadata({ effects });
                    }
                    dataVersion = edge.to.metadata;
                    await setDataVersion(effects, edge.to.metadata);
                }
                return dataVersion;
            }
        }
        throw new Error(`cannot migrate from ${from.toString()} to ${to.toString()}`);
    }
    async init(effects, kind) {
        const from = await getDataVersion(effects);
        if (from) {
            await this.migrate({
                effects,
                from,
                to: this.currentVersion(),
            });
        }
        else {
            kind = "install"; // implied by !dataVersion
            if (this.preInstall)
                if ("init" in this.preInstall)
                    await this.preInstall.init(effects, kind);
                else
                    await this.preInstall(effects, kind);
            await effects.setDataVersion({ version: this.current.options.version });
        }
    }
    async uninit(effects, target) {
        if (target) {
            const from = await getDataVersion(effects);
            if (from) {
                target = await this.migrate({
                    effects,
                    from,
                    to: target,
                });
            }
        }
        else {
            if (this.uninstall)
                if ("uninit" in this.uninstall)
                    await this.uninstall.uninit(effects, target);
                else
                    await this.uninstall(effects, target);
        }
        await setDataVersion(effects, target);
    }
}
exports.VersionGraph = VersionGraph;
//# sourceMappingURL=VersionGraph.js.map