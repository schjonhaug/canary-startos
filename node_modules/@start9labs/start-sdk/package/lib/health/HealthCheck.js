"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HealthCheck = void 0;
const defaultTrigger_1 = require("../trigger/defaultTrigger");
const util_1 = require("../util");
const ts_matches_1 = require("ts-matches");
class HealthCheck extends util_1.Drop {
    constructor(effects, o) {
        super();
        this.started = null;
        this.setStarted = (started) => {
            this.started = started;
        };
        this.exited = false;
        this.exit = () => {
            this.exited = true;
        };
        this.currentValue = {};
        this.promise = Promise.resolve().then(async () => {
            const getCurrentValue = () => this.currentValue;
            const gracePeriod = o.gracePeriod ?? 10_000;
            const trigger = (o.trigger ?? defaultTrigger_1.defaultTrigger)(getCurrentValue);
            const checkStarted = () => [
                this.started,
                new Promise((resolve) => {
                    this.setStarted = (started) => {
                        this.started = started;
                        resolve();
                    };
                    this.exit = () => {
                        this.exited = true;
                        resolve();
                    };
                }),
            ];
            let triggered = false;
            while (!this.exited) {
                const [started, changed] = checkStarted();
                let race = [
                    changed,
                ];
                if (started) {
                    race = [...race, trigger.next()];
                    if (triggered) {
                        try {
                            let { result, message } = await o.fn();
                            if (result === "failure" &&
                                performance.now() - started <= gracePeriod)
                                result = "starting";
                            await effects.setHealth({
                                name: o.name,
                                id: o.id,
                                result,
                                message: message || "",
                            });
                            this.currentValue.lastResult = result;
                        }
                        catch (e) {
                            await effects.setHealth({
                                name: o.name,
                                id: o.id,
                                result: performance.now() - started <= gracePeriod
                                    ? "starting"
                                    : "failure",
                                message: asMessage(e) || "",
                            });
                            this.currentValue.lastResult = "failure";
                        }
                    }
                }
                else
                    triggered = false;
                const raced = await Promise.race(race);
                if (raced) {
                    if (raced.done)
                        break;
                    triggered = true;
                }
            }
        });
    }
    static of(effects, options) {
        return new HealthCheck(effects, options);
    }
    start() {
        if (this.started)
            return;
        this.setStarted(performance.now());
    }
    stop() {
        if (!this.started)
            return;
        this.setStarted(null);
    }
    onDrop() {
        this.exit();
    }
}
exports.HealthCheck = HealthCheck;
function asMessage(e) {
    if ((0, ts_matches_1.object)({ message: ts_matches_1.unknown }).test(e))
        return String(e.message);
    const value = String(e);
    if (value.length == null)
        return null;
    return value;
}
//# sourceMappingURL=HealthCheck.js.map