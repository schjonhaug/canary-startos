import * as T from "../../../base/lib/types";
import { Drop } from "../util";
import { SubContainer, SubContainerRc } from "../util/SubContainer";
import { CommandController } from "./CommandController";
import { DaemonCommandType } from "./Daemons";
import { Oneshot } from "./Oneshot";
/**
 * This is a wrapper around CommandController that has a state of off, where the command shouldn't be running
 * and the others state of running, where it will keep a living running command
 */
export declare class Daemon<Manifest extends T.SDKManifest, C extends SubContainer<Manifest> | null = SubContainer<Manifest> | null> extends Drop {
    private subcontainer;
    private startCommand;
    readonly oneshot: boolean;
    private commandController;
    private shouldBeRunning;
    protected exitedSuccess: boolean;
    private onExitFns;
    protected constructor(subcontainer: C, startCommand: () => Promise<CommandController<Manifest, C>>, oneshot?: boolean);
    isOneshot(): this is Oneshot<Manifest>;
    static of<Manifest extends T.SDKManifest>(): <C extends SubContainer<Manifest> | null>(effects: T.Effects, subcontainer: C, exec: DaemonCommandType<Manifest, C>) => Promise<Daemon<Manifest, SubContainer<Manifest, T.Effects> | null>>;
    start(): Promise<void>;
    term(termOptions?: {
        signal?: NodeJS.Signals | undefined;
        timeout?: number | undefined;
    }): Promise<void>;
    stop(termOptions?: {
        signal?: NodeJS.Signals | undefined;
        timeout?: number | undefined;
    }): Promise<void>;
    subcontainerRc(): SubContainerRc<Manifest> | null;
    onExit(fn: (success: boolean) => void): void;
    onDrop(): void;
}
