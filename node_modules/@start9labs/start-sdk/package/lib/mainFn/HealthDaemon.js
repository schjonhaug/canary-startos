"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HealthDaemon = exports.EXIT_SUCCESS = void 0;
const defaultTrigger_1 = require("../trigger/defaultTrigger");
const asError_1 = require("../../../base/lib/util/asError");
const oncePromise = () => {
    let resolve;
    const promise = new Promise((res) => {
        resolve = res;
    });
    return { resolve: resolve, promise };
};
exports.EXIT_SUCCESS = "EXIT_SUCCESS";
/**
 * Wanted a structure that deals with controlling daemons by their health status
 * States:
 * -- Waiting for dependencies to be success
 * -- Running: Daemon is running and the status is in the health
 *
 */
class HealthDaemon {
    constructor(daemon, dependencies, id, ready, effects) {
        this.daemon = daemon;
        this.dependencies = dependencies;
        this.id = id;
        this.ready = ready;
        this.effects = effects;
        this._health = { result: "starting", message: null };
        this.healthWatchers = [];
        this.running = false;
        this.resolvedReady = false;
        this.healthCheckCleanup = null;
        this.readyPromise = new Promise((resolve) => (this.resolveReady = () => {
            resolve();
            this.resolvedReady = true;
        }));
        this.dependencies.forEach((d) => d.addWatcher(() => this.updateStatus()));
    }
    /** Run after we want to do cleanup */
    async term(termOptions) {
        this.healthWatchers = [];
        this.running = false;
        this.healthCheckCleanup?.();
        await this.daemon?.then((d) => d.term({
            ...termOptions,
        }));
    }
    /** Want to add another notifier that the health might have changed */
    addWatcher(watcher) {
        this.healthWatchers.push(watcher);
    }
    get health() {
        return Object.freeze(this._health);
    }
    async changeRunning(newStatus) {
        if (this.running === newStatus)
            return;
        this.running = newStatus;
        if (newStatus) {
            console.debug(`Launching ${this.id}...`);
            this.setupHealthCheck();
            (await this.daemon)?.start();
            this.started = performance.now();
        }
        else {
            console.debug(`Stopping ${this.id}...`);
            (await this.daemon)?.stop();
            this.turnOffHealthCheck();
            this.setHealth({ result: "starting", message: null });
        }
    }
    turnOffHealthCheck() {
        this.healthCheckCleanup?.();
        this.resolvedReady = false;
        this.readyPromise = new Promise((resolve) => (this.resolveReady = () => {
            resolve();
            this.resolvedReady = true;
        }));
    }
    async setupHealthCheck() {
        const daemon = await this.daemon;
        daemon?.onExit((success) => {
            if (success && this.ready === "EXIT_SUCCESS") {
                this.setHealth({ result: "success", message: null });
            }
            else if (!success) {
                this.setHealth({
                    result: "failure",
                    message: `${this.id} daemon crashed`,
                });
            }
            else if (!daemon.isOneshot()) {
                this.setHealth({
                    result: "failure",
                    message: `${this.id} daemon exited`,
                });
            }
        });
        if (this.ready === "EXIT_SUCCESS")
            return;
        if (this.healthCheckCleanup)
            return;
        const trigger = (this.ready.trigger ?? defaultTrigger_1.defaultTrigger)(() => ({
            lastResult: this._health.result,
        }));
        const { promise: status, resolve: setStatus } = oncePromise();
        new Promise(async () => {
            if (this.ready === "EXIT_SUCCESS")
                return;
            for (let res = await Promise.race([status, trigger.next()]); !res.done; res = await Promise.race([status, trigger.next()])) {
                const response = await Promise.resolve(this.ready.fn()).catch((err) => {
                    console.error((0, asError_1.asError)(err));
                    return {
                        result: "failure",
                        message: "message" in err ? err.message : String(err),
                    };
                });
                await this.setHealth(response);
            }
        }).catch((err) => console.error(`Daemon ${this.id} failed: ${err}`));
        this.healthCheckCleanup = () => {
            setStatus({ done: true });
            this.healthCheckCleanup = null;
            return null;
        };
    }
    onReady() {
        return this.readyPromise;
    }
    get isReady() {
        return this.resolvedReady;
    }
    async setHealth(health) {
        const changed = this._health.result !== health.result;
        this._health = health;
        if (this.resolveReady && health.result === "success") {
            this.resolveReady();
        }
        if (changed)
            this.healthWatchers.forEach((watcher) => watcher());
        if (this.ready === "EXIT_SUCCESS")
            return;
        const display = this.ready.display;
        if (!display) {
            return;
        }
        let result = health.result;
        if (result === "failure" &&
            this.started &&
            performance.now() - this.started <= (this.ready.gracePeriod ?? 10_000))
            result = "starting";
        await this.effects.setHealth({
            ...health,
            id: this.id,
            name: display,
            result,
        });
    }
    async updateStatus() {
        const healths = this.dependencies.map((d) => ({
            health: d.running && d._health,
            id: d.id,
        }));
        const waitingOn = healths.filter((h) => !h.health || h.health.result !== "success");
        if (waitingOn.length)
            console.debug(`daemon ${this.id} waiting on ${waitingOn.map((w) => w.id)}`);
        this.changeRunning(!waitingOn.length);
    }
    async init() {
        if (this.ready !== "EXIT_SUCCESS" && this.ready.display) {
            this.effects.setHealth({
                id: this.id,
                message: null,
                name: this.ready.display,
                result: "starting",
            });
        }
        await this.updateStatus();
    }
}
exports.HealthDaemon = HealthDaemon;
//# sourceMappingURL=HealthDaemon.js.map