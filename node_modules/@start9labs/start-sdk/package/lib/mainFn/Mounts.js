"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mounts = void 0;
class Mounts {
    constructor(volumes, assets, dependencies, backups) {
        this.volumes = volumes;
        this.assets = assets;
        this.dependencies = dependencies;
        this.backups = backups;
    }
    static of() {
        return new Mounts([], [], [], []);
    }
    mountVolume(options) {
        return new Mounts([...this.volumes, options], [...this.assets], [...this.dependencies], [...this.backups]);
    }
    mountAssets(options) {
        return new Mounts([...this.volumes], [...this.assets, options], [...this.dependencies], [...this.backups]);
    }
    mountDependency(options) {
        return new Mounts([...this.volumes], [...this.assets], [...this.dependencies, options], [...this.backups]);
    }
    mountBackups(options) {
        return new Mounts([...this.volumes], [...this.assets], [...this.dependencies], [...this.backups, options]);
    }
    build() {
        const mountpoints = new Set();
        for (let mountpoint of this.volumes
            .map((v) => v.mountpoint)
            .concat(this.assets.map((a) => a.mountpoint))
            .concat(this.dependencies.map((d) => d.mountpoint))) {
            if (mountpoints.has(mountpoint)) {
                throw new Error(`cannot mount more than once to mountpoint ${mountpoint}`);
            }
            mountpoints.add(mountpoint);
        }
        return []
            .concat(this.volumes.map((v) => ({
            mountpoint: v.mountpoint,
            options: {
                type: "volume",
                volumeId: v.volumeId,
                subpath: v.subpath,
                readonly: v.readonly,
                filetype: v.type ?? "directory",
            },
        })))
            .concat(this.assets.map((a) => ({
            mountpoint: a.mountpoint,
            options: {
                type: "assets",
                subpath: a.subpath,
                filetype: a.type ?? "directory",
            },
        })))
            .concat(this.dependencies.map((d) => ({
            mountpoint: d.mountpoint,
            options: {
                type: "pointer",
                packageId: d.dependencyId,
                volumeId: d.volumeId,
                subpath: d.subpath,
                readonly: d.readonly,
                filetype: d.type ?? "directory",
            },
        })));
    }
}
exports.Mounts = Mounts;
const a = Mounts.of().mountBackups({ subpath: null, mountpoint: "" });
// @ts-expect-error
const m = a;
//# sourceMappingURL=Mounts.js.map