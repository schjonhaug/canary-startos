"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Daemon = void 0;
const asError_1 = require("../../../base/lib/util/asError");
const util_1 = require("../util");
const CommandController_1 = require("./CommandController");
const TIMEOUT_INCREMENT_MS = 1000;
const MAX_TIMEOUT_MS = 30000;
/**
 * This is a wrapper around CommandController that has a state of off, where the command shouldn't be running
 * and the others state of running, where it will keep a living running command
 */
class Daemon extends util_1.Drop {
    constructor(subcontainer, startCommand, oneshot = false) {
        super();
        this.subcontainer = subcontainer;
        this.startCommand = startCommand;
        this.oneshot = oneshot;
        this.commandController = null;
        this.shouldBeRunning = false;
        this.exitedSuccess = false;
        this.onExitFns = [];
    }
    isOneshot() {
        return this.oneshot;
    }
    static of() {
        return async (effects, subcontainer, exec) => {
            let subc = subcontainer;
            if (subcontainer && subcontainer.isOwned())
                subc = subcontainer.rc();
            const startCommand = () => CommandController_1.CommandController.of()(effects, (subc?.rc() ?? null), exec);
            const res = new Daemon(subc, startCommand);
            effects.onLeaveContext(() => {
                res.stop().catch((e) => console.error((0, asError_1.asError)(e)));
            });
            return res;
        };
    }
    async start() {
        if (this.commandController) {
            return;
        }
        this.shouldBeRunning = true;
        let timeoutCounter = 0;
        (async () => {
            while (this.shouldBeRunning) {
                if (this.commandController)
                    await this.commandController
                        .term({})
                        .catch((err) => console.error(err));
                try {
                    this.commandController = await this.startCommand();
                    if (!this.shouldBeRunning) {
                        // handles race condition if stopped while starting
                        await this.stop();
                        break;
                    }
                    const success = await this.commandController.wait().then((_) => true, (err) => {
                        console.error(err);
                        return false;
                    });
                    for (const fn of this.onExitFns) {
                        try {
                            fn(success);
                        }
                        catch (e) {
                            console.error("EXIT handler", e);
                        }
                    }
                    if (success && this.oneshot) {
                        this.exitedSuccess = true;
                        break;
                    }
                }
                catch (e) {
                    console.error(e);
                }
                await new Promise((resolve) => setTimeout(resolve, timeoutCounter));
                timeoutCounter += TIMEOUT_INCREMENT_MS;
                timeoutCounter = Math.min(MAX_TIMEOUT_MS, timeoutCounter);
            }
        })().catch((err) => {
            console.error((0, asError_1.asError)(err));
        });
    }
    async term(termOptions) {
        return this.stop(termOptions);
    }
    async stop(termOptions) {
        this.shouldBeRunning = false;
        this.exitedSuccess = false;
        if (this.commandController) {
            await this.commandController
                .term({ ...termOptions })
                .catch((e) => console.error((0, asError_1.asError)(e)));
            this.commandController = null;
            this.onExitFns = [];
            await this.subcontainer?.destroy();
        }
    }
    subcontainerRc() {
        return this.subcontainer?.rc() ?? null;
    }
    onExit(fn) {
        this.onExitFns.push(fn);
    }
    onDrop() {
        this.stop().catch((e) => console.error((0, asError_1.asError)(e)));
    }
}
exports.Daemon = Daemon;
//# sourceMappingURL=Daemon.js.map