import * as T from "../types";
import * as IST from "../actions/input/inputSpecTypes";
import { Action, ActionInfo } from "./setupActions";
export type RunActionInput<Input> = Input | ((prev?: {
    spec: IST.InputSpec;
    value: Input | null;
}) => Input);
export declare const runAction: <Input extends Record<string, unknown>>(options: {
    effects: T.Effects;
    actionId: T.ActionId;
    input?: RunActionInput<Input>;
}) => Promise<T.ActionResult | null>;
type GetActionInputType<A extends ActionInfo<T.ActionId, any>> = A extends Action<T.ActionId, infer I> ? I : never;
type TaskBase = {
    reason?: string;
    replayId?: string;
};
type TaskInput<T extends ActionInfo<T.ActionId, any>> = {
    kind: "partial";
    value: T.DeepPartial<GetActionInputType<T>>;
};
export type TaskOptions<T extends ActionInfo<T.ActionId, any>> = TaskBase & ({
    when?: Exclude<T.TaskTrigger, {
        condition: "input-not-matches";
    }>;
    input?: TaskInput<T>;
} | {
    when: T.TaskTrigger & {
        condition: "input-not-matches";
    };
    input: TaskInput<T>;
});
export declare const createTask: <T extends ActionInfo<T.ActionId, any>>(options: {
    effects: T.Effects;
    packageId: T.PackageId;
    action: T;
    severity: T.TaskSeverity;
    options?: TaskOptions<T>;
}) => Promise<null>;
export {};
