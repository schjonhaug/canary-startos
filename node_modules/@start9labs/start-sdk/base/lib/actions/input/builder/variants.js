"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Variants = void 0;
const ts_matches_1 = require("ts-matches");
/**
 * Used in the the Value.select { @link './value.ts' }
 * to indicate the type of select variants that are available. The key for the record passed in will be the
 * key to the tag.id in the Value.select
```ts
 
export const disabled = InputSpec.of({});
export const size = Value.number({
  name: "Max Chain Size",
  default: 550,
  description: "Limit of blockchain size on disk.",
  warning: "Increasing this value will require re-syncing your node.",
  required: true,
  range: "[550,1000000)",
  integral: true,
  units: "MiB",
  placeholder: null,
});
export const automatic = InputSpec.of({ size: size });
export const size1 = Value.number({
  name: "Failsafe Chain Size",
  default: 65536,
  description: "Prune blockchain if size expands beyond this.",
  warning: null,
  required: true,
  range: "[550,1000000)",
  integral: true,
  units: "MiB",
  placeholder: null,
});
export const manual = InputSpec.of({ size: size1 });
export const pruningSettingsVariants = Variants.of({
  disabled: { name: "Disabled", spec: disabled },
  automatic: { name: "Automatic", spec: automatic },
  manual: { name: "Manual", spec: manual },
});
export const pruning = Value.union(
  {
    name: "Pruning Settings",
    description:
      '- Disabled: Disable pruning\n- Automatic: Limit blockchain size on disk to a certain number of megabytes\n- Manual: Prune blockchain with the "pruneblockchain" RPC\n',
    warning: null,
    default: "disabled",
  },
  pruningSettingsVariants
);
```
 */
class Variants {
    constructor(build, validator) {
        this.build = build;
        this.validator = validator;
        this._TYPE = null;
    }
    static of(a) {
        const staticValidators = {};
        for (const key in a) {
            const value = a[key];
            staticValidators[key] = value.spec.validator;
        }
        const other = (0, ts_matches_1.object)(Object.fromEntries(Object.entries(staticValidators).map(([k, v]) => [k, ts_matches_1.any.optional()]))).optional();
        return new Variants(async (options) => {
            const validators = {};
            const variants = {};
            for (const key in a) {
                const value = a[key];
                const built = await value.spec.build(options);
                variants[key] = {
                    name: value.name,
                    spec: built.spec,
                };
                validators[key] = built.validator;
            }
            const other = (0, ts_matches_1.object)(Object.fromEntries(Object.entries(validators).map(([k, v]) => [k, ts_matches_1.any.optional()]))).optional();
            return {
                spec: variants,
                validator: (0, ts_matches_1.anyOf)(...Object.entries(validators).map(([k, v]) => (0, ts_matches_1.object)({
                    selection: (0, ts_matches_1.literal)(k),
                    value: v,
                    other,
                }))),
            };
        }, (0, ts_matches_1.anyOf)(...Object.entries(staticValidators).map(([k, v]) => (0, ts_matches_1.object)({
            selection: (0, ts_matches_1.literal)(k),
            value: v,
            other,
        }))));
    }
}
exports.Variants = Variants;
//# sourceMappingURL=variants.js.map