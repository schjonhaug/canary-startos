"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetServiceInterfaces = void 0;
exports.getServiceInterfaces = getServiceInterfaces;
const Drop_1 = require("./Drop");
const getServiceInterface_1 = require("./getServiceInterface");
const makeManyInterfaceFilled = async ({ effects, packageId, callback, }) => {
    const serviceInterfaceValues = await effects.listServiceInterfaces({
        packageId,
        callback,
    });
    const serviceInterfacesFilled = await Promise.all(Object.values(serviceInterfaceValues).map(async (serviceInterfaceValue) => {
        const hostId = serviceInterfaceValue.addressInfo.hostId;
        const host = await effects.getHostInfo({
            packageId,
            hostId,
            callback,
        });
        if (!host) {
            throw new Error(`host ${hostId} not found!`);
        }
        return {
            ...serviceInterfaceValue,
            host,
            addressInfo: (0, getServiceInterface_1.filledAddress)(host, serviceInterfaceValue.addressInfo),
        };
    }));
    return serviceInterfacesFilled;
};
class GetServiceInterfaces {
    constructor(effects, opts) {
        this.effects = effects;
        this.opts = opts;
    }
    /**
     * Returns the service interfaces for the package. Reruns the context from which it has been called if the underlying value changes
     */
    async const() {
        const { packageId } = this.opts;
        const callback = this.effects.constRetry &&
            (() => this.effects.constRetry && this.effects.constRetry());
        const interfaceFilled = await makeManyInterfaceFilled({
            effects: this.effects,
            packageId,
            callback,
        });
        return interfaceFilled;
    }
    /**
     * Returns the service interfaces for the package. Does nothing if the value changes
     */
    async once() {
        const { packageId } = this.opts;
        const interfaceFilled = await makeManyInterfaceFilled({
            effects: this.effects,
            packageId,
        });
        return interfaceFilled;
    }
    async *watchGen(abort) {
        const { packageId } = this.opts;
        const resolveCell = { resolve: () => { } };
        this.effects.onLeaveContext(() => {
            resolveCell.resolve();
        });
        abort?.addEventListener("abort", () => resolveCell.resolve());
        while (this.effects.isInContext && !abort?.aborted) {
            let callback = () => { };
            const waitForNext = new Promise((resolve) => {
                callback = resolve;
                resolveCell.resolve = resolve;
            });
            yield await makeManyInterfaceFilled({
                effects: this.effects,
                packageId,
                callback,
            });
            await waitForNext;
        }
    }
    /**
     * Watches the service interfaces for the package. Returns an async iterator that yields whenever the value changes
     */
    watch(abort) {
        const ctrl = new AbortController();
        abort?.addEventListener("abort", () => ctrl.abort());
        return Drop_1.DropGenerator.of(this.watchGen(ctrl.signal), () => ctrl.abort());
    }
    /**
     * Watches the service interfaces for the package. Takes a custom callback function to run whenever the value changes
     */
    onChange(callback) {
        ;
        (async () => {
            const ctrl = new AbortController();
            for await (const value of this.watch(ctrl.signal)) {
                try {
                    const res = await callback(value);
                    if (res.cancel) {
                        ctrl.abort();
                        break;
                    }
                }
                catch (e) {
                    console.error("callback function threw an error @ GetServiceInterfaces.onChange", e);
                }
            }
        })()
            .catch((e) => callback(null, e))
            .catch((e) => console.error("callback function threw an error @ GetServiceInterfaces.onChange", e));
    }
    /**
     * Watches the service interfaces for the package. Returns when the predicate is true
     */
    waitFor(pred) {
        const ctrl = new AbortController();
        return Drop_1.DropPromise.of(Promise.resolve().then(async () => {
            for await (const next of this.watchGen(ctrl.signal)) {
                if (pred(next)) {
                    return next;
                }
            }
            return null;
        }), () => ctrl.abort());
    }
}
exports.GetServiceInterfaces = GetServiceInterfaces;
function getServiceInterfaces(effects, opts) {
    return new GetServiceInterfaces(effects, opts);
}
//# sourceMappingURL=getServiceInterfaces.js.map