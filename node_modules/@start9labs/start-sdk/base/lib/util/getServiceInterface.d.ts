import { ServiceInterfaceType } from "../types";
import { AddressInfo, Host, Hostname, HostnameInfo } from "../types";
import { Effects } from "../Effects";
export type UrlString = string;
export type HostId = string;
export declare const getHostname: (url: string) => Hostname | null;
type FilterKinds = "onion" | "local" | "domain" | "ip" | "ipv4" | "ipv6" | "localhost" | "link-local";
export type Filter = {
    visibility?: "public" | "private";
    kind?: FilterKinds | FilterKinds[];
    predicate?: (h: HostnameInfo) => boolean;
    exclude?: Filter;
};
type VisibilityFilter<V extends "public" | "private"> = V extends "public" ? (HostnameInfo & {
    public: true;
}) | VisibilityFilter<Exclude<V, "public">> : V extends "private" ? (HostnameInfo & {
    public: false;
}) | VisibilityFilter<Exclude<V, "private">> : never;
type KindFilter<K extends FilterKinds> = K extends "onion" ? (HostnameInfo & {
    kind: "onion";
}) | KindFilter<Exclude<K, "onion">> : K extends "local" ? (HostnameInfo & {
    kind: "ip";
    hostname: {
        kind: "local";
    };
}) | KindFilter<Exclude<K, "local">> : K extends "domain" ? (HostnameInfo & {
    kind: "ip";
    hostname: {
        kind: "domain";
    };
}) | KindFilter<Exclude<K, "domain">> : K extends "ipv4" ? (HostnameInfo & {
    kind: "ip";
    hostname: {
        kind: "ipv4";
    };
}) | KindFilter<Exclude<K, "ipv4">> : K extends "ipv6" ? (HostnameInfo & {
    kind: "ip";
    hostname: {
        kind: "ipv6";
    };
}) | KindFilter<Exclude<K, "ipv6">> : K extends "ip" ? KindFilter<Exclude<K, "ip"> | "ipv4" | "ipv6"> : never;
type FilterReturnTy<F extends Filter> = F extends {
    visibility: infer V extends "public" | "private";
} ? VisibilityFilter<V> & FilterReturnTy<Omit<F, "visibility">> : F extends {
    kind: (infer K extends FilterKinds) | (infer K extends FilterKinds)[];
} ? KindFilter<K> & FilterReturnTy<Omit<F, "kind">> : F extends {
    predicate: (h: HostnameInfo) => h is infer H extends HostnameInfo;
} ? H & FilterReturnTy<Omit<F, "predicate">> : F extends {
    exclude: infer E extends Filter;
} ? HostnameInfo extends FilterReturnTy<E> ? HostnameInfo : Exclude<HostnameInfo, FilterReturnTy<E>> : HostnameInfo;
declare const defaultFilter: {
    exclude: {
        kind: ("localhost" | "link-local")[];
    };
};
type Formats = "hostname-info" | "urlstring" | "url";
type FormatReturnTy<F extends Filter, Format extends Formats> = Format extends "hostname-info" ? FilterReturnTy<F> | FormatReturnTy<F, Exclude<Format, "hostname-info">> : Format extends "url" ? URL | FormatReturnTy<F, Exclude<Format, "url">> : Format extends "urlstring" ? UrlString | FormatReturnTy<F, Exclude<Format, "urlstring">> : never;
export type Filled = {
    hostnames: HostnameInfo[];
    toUrls: (h: HostnameInfo) => {
        url: UrlString | null;
        sslUrl: UrlString | null;
    };
    filter: <F extends Filter = typeof defaultFilter, Format extends Formats = "urlstring">(filter?: F, format?: Format) => FormatReturnTy<F, Format>[];
    publicHostnames: HostnameInfo[];
    onionHostnames: HostnameInfo[];
    localHostnames: HostnameInfo[];
    ipHostnames: HostnameInfo[];
    ipv4Hostnames: HostnameInfo[];
    ipv6Hostnames: HostnameInfo[];
    nonIpHostnames: HostnameInfo[];
    urls: UrlString[];
    publicUrls: UrlString[];
    onionUrls: UrlString[];
    localUrls: UrlString[];
    ipUrls: UrlString[];
    ipv4Urls: UrlString[];
    ipv6Urls: UrlString[];
    nonIpUrls: UrlString[];
};
export type FilledAddressInfo = AddressInfo & Filled;
export type ServiceInterfaceFilled = {
    id: string;
    /** The title of this field to be displayed */
    name: string;
    /** Human readable description, used as tooltip usually */
    description: string;
    /** Whether or not to mask the URIs for this interface. Useful if the URIs contain sensitive information, such as a password, macaroon, or API key */
    masked: boolean;
    /** Information about the host for this binding */
    host: Host | null;
    /** URI information */
    addressInfo: FilledAddressInfo | null;
    /** Indicates if we are a ui/p2p/api for the kind of interface that this is representing */
    type: ServiceInterfaceType;
};
export declare const addressHostToUrl: ({ scheme, sslScheme, username, suffix }: AddressInfo, hostname: HostnameInfo) => {
    url: UrlString | null;
    sslUrl: UrlString | null;
};
export declare const filledAddress: (host: Host, addressInfo: AddressInfo) => FilledAddressInfo;
export declare class GetServiceInterface {
    readonly effects: Effects;
    readonly opts: {
        id: string;
        packageId?: string;
    };
    constructor(effects: Effects, opts: {
        id: string;
        packageId?: string;
    });
    /**
     * Returns the requested service interface. Reruns the context from which it has been called if the underlying value changes
     */
    const(): Promise<ServiceInterfaceFilled | null>;
    /**
     * Returns the requested service interface. Does nothing if the value changes
     */
    once(): Promise<ServiceInterfaceFilled | null>;
    private watchGen;
    /**
     * Watches the requested service interface. Returns an async iterator that yields whenever the value changes
     */
    watch(abort?: AbortSignal): AsyncGenerator<ServiceInterfaceFilled | null, void, unknown>;
    /**
     * Watches the requested service interface. Takes a custom callback function to run whenever the value changes
     */
    onChange(callback: (value: ServiceInterfaceFilled | null, error?: Error) => {
        cancel: boolean;
    } | Promise<{
        cancel: boolean;
    }>): void;
    /**
     * Watches the requested service interface. Returns when the predicate is true
     */
    waitFor(pred: (value: ServiceInterfaceFilled | null) => boolean): Promise<ServiceInterfaceFilled | null>;
}
export declare function getServiceInterface(effects: Effects, opts: {
    id: string;
    packageId?: string;
}): GetServiceInterface;
export {};
