import * as T from "../types";
export type FlattenIntersection<T> = T extends ArrayLike<any> ? T : T extends object ? {} & {
    [P in keyof T]: T[P];
} : T;
export type _<T> = FlattenIntersection<T>;
export declare const isKnownError: (e: unknown) => e is T.KnownError;
declare const affine: unique symbol;
export type Affine<A> = {
    [affine]: A;
};
type NeverPossible = {
    [affine]: string;
};
export type NoAny<A> = NeverPossible extends A ? keyof NeverPossible extends keyof A ? never : A : A;
type CapitalLetters = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z";
type Numbers = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
type CapitalChars = CapitalLetters | Numbers;
export type ToKebab<S extends string> = S extends string ? S extends `${infer Head}${CapitalChars}${infer Tail}` ? Head extends "" ? Tail extends "" ? Lowercase<S> : S extends `${infer Caps}${Tail}` ? Caps extends CapitalChars ? Tail extends CapitalLetters ? `${Lowercase<Caps>}-${Lowercase<Tail>}` : Tail extends `${CapitalLetters}${string}` ? `${ToKebab<Caps>}-${ToKebab<Tail>}` : `${ToKebab<Caps>}${ToKebab<Tail>}` : never : never : Tail extends "" ? S extends `${Head}${infer Caps}` ? Caps extends CapitalChars ? Head extends Lowercase<Head> ? Caps extends Numbers ? Head extends `${string}${Numbers}` ? never : `${ToKebab<Head>}-${Caps}` : `${ToKebab<Head>}-${ToKebab<Caps>}` : never : never : never : S extends `${Head}${infer Caps}${Tail}` ? Caps extends CapitalChars ? Head extends Lowercase<Head> ? Tail extends CapitalLetters ? `${ToKebab<Head>}-${ToKebab<Caps>}-${Lowercase<Tail>}` : Tail extends `${CapitalLetters}${string}` ? Head extends Numbers ? never : Head extends `${string}${Numbers}` ? never : `${Head}-${ToKebab<Caps>}-${ToKebab<Tail>}` : `${ToKebab<Head>}-${Lowercase<Caps>}${ToKebab<Tail>}` : never : never : never : S : never;
export type StringObject = Record<string, unknown>;
export {};
