"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetServiceInterface = exports.filledAddress = exports.addressHostToUrl = exports.getHostname = void 0;
exports.getServiceInterface = getServiceInterface;
const Host_1 = require("../interfaces/Host");
const Drop_1 = require("./Drop");
const ip_1 = require("./ip");
const getHostnameRegex = /^(\w+:\/\/)?([^\/\:]+)(:\d{1,3})?(\/)?/;
const getHostname = (url) => {
    const founds = url.match(getHostnameRegex)?.[2];
    if (!founds)
        return null;
    const parts = founds.split("@");
    const last = parts[parts.length - 1];
    return last;
};
exports.getHostname = getHostname;
const defaultFilter = {
    exclude: {
        kind: ["localhost", "link-local"],
    },
};
const either = (...args) => (a) => args.some((x) => x(a));
const negate = (fn) => (a) => !fn(a);
const unique = (values) => Array.from(new Set(values));
const addressHostToUrl = ({ scheme, sslScheme, username, suffix }, hostname) => {
    const res = [];
    const fmt = (scheme, host, port) => {
        const excludePort = scheme &&
            scheme in Host_1.knownProtocols &&
            port === Host_1.knownProtocols[scheme].defaultPort;
        let hostname;
        if (host.kind === "onion") {
            hostname = host.hostname.value;
        }
        else if (host.kind === "ip") {
            if (host.hostname.kind === "domain") {
                hostname = host.hostname.value;
            }
            else if (host.hostname.kind === "ipv6") {
                hostname = ip_1.IPV6_LINK_LOCAL.contains(host.hostname.value)
                    ? `[${host.hostname.value}%${host.hostname.scopeId}]`
                    : `[${host.hostname.value}]`;
            }
            else {
                hostname = host.hostname.value;
            }
        }
        return `${scheme ? `${scheme}://` : ""}${username ? `${username}@` : ""}${hostname}${excludePort ? "" : `:${port}`}${suffix}`;
    };
    let url = null;
    if (hostname.hostname.port !== null) {
        url = fmt(scheme, hostname, hostname.hostname.port);
    }
    let sslUrl = null;
    if (hostname.hostname.sslPort !== null) {
        sslUrl = fmt(sslScheme, hostname, hostname.hostname.sslPort);
    }
    return { url, sslUrl };
};
exports.addressHostToUrl = addressHostToUrl;
function filterRec(hostnames, filter, invert) {
    if (filter.predicate) {
        const pred = filter.predicate;
        hostnames = hostnames.filter((h) => invert !== pred(h));
    }
    if (filter.visibility === "public")
        hostnames = hostnames.filter((h) => invert !== (h.kind === "onion" || h.public));
    if (filter.visibility === "private")
        hostnames = hostnames.filter((h) => invert !== (h.kind !== "onion" && !h.public));
    if (filter.kind) {
        const kind = new Set(Array.isArray(filter.kind) ? filter.kind : [filter.kind]);
        if (kind.has("ip")) {
            kind.add("ipv4");
            kind.add("ipv6");
        }
        hostnames = hostnames.filter((h) => invert !==
            ((kind.has("onion") && h.kind === "onion") ||
                (kind.has("local") &&
                    h.kind === "ip" &&
                    h.hostname.kind === "local") ||
                (kind.has("domain") &&
                    h.kind === "ip" &&
                    h.hostname.kind === "domain") ||
                (kind.has("ipv4") && h.kind === "ip" && h.hostname.kind === "ipv4") ||
                (kind.has("ipv6") && h.kind === "ip" && h.hostname.kind === "ipv6") ||
                (kind.has("localhost") &&
                    ["localhost", "127.0.0.1", "[::1]"].includes(h.hostname.value)) ||
                (kind.has("link-local") &&
                    h.kind === "ip" &&
                    h.hostname.kind === "ipv6" &&
                    ip_1.IPV6_LINK_LOCAL.contains(ip_1.IpAddress.parse(h.hostname.value)))));
    }
    if (filter.exclude)
        return filterRec(hostnames, filter.exclude, !invert);
    return hostnames;
}
const filledAddress = (host, addressInfo) => {
    const toUrls = exports.addressHostToUrl.bind(null, addressInfo);
    const toUrlArray = (h) => {
        const u = toUrls(h);
        return [u.url, u.sslUrl].filter((u) => u !== null);
    };
    const hostnames = host.hostnameInfo[addressInfo.internalPort] ?? [];
    return {
        ...addressInfo,
        hostnames,
        toUrls,
        filter: (filter, format) => {
            const filtered = filterRec(hostnames, filter ?? defaultFilter, false);
            let res = filtered;
            if (format === "hostname-info")
                return res;
            const urls = filtered.flatMap(toUrlArray);
            if (format === "url")
                res = urls.map((u) => new URL(u));
            else
                res = urls;
            return res;
        },
        get publicHostnames() {
            return hostnames.filter((h) => h.kind === "onion" || h.public);
        },
        get onionHostnames() {
            return hostnames.filter((h) => h.kind === "onion");
        },
        get localHostnames() {
            return hostnames.filter((h) => h.kind === "ip" && h.hostname.kind === "local");
        },
        get ipHostnames() {
            return hostnames.filter((h) => h.kind === "ip" &&
                (h.hostname.kind === "ipv4" || h.hostname.kind === "ipv6"));
        },
        get ipv4Hostnames() {
            return hostnames.filter((h) => h.kind === "ip" && h.hostname.kind === "ipv4");
        },
        get ipv6Hostnames() {
            return hostnames.filter((h) => h.kind === "ip" && h.hostname.kind === "ipv6");
        },
        get nonIpHostnames() {
            return hostnames.filter((h) => h.kind === "ip" &&
                h.hostname.kind !== "ipv4" &&
                h.hostname.kind !== "ipv6");
        },
        get urls() {
            return this.hostnames.flatMap(toUrlArray);
        },
        get publicUrls() {
            return this.publicHostnames.flatMap(toUrlArray);
        },
        get onionUrls() {
            return this.onionHostnames.flatMap(toUrlArray);
        },
        get localUrls() {
            return this.localHostnames.flatMap(toUrlArray);
        },
        get ipUrls() {
            return this.ipHostnames.flatMap(toUrlArray);
        },
        get ipv4Urls() {
            return this.ipv4Hostnames.flatMap(toUrlArray);
        },
        get ipv6Urls() {
            return this.ipv6Hostnames.flatMap(toUrlArray);
        },
        get nonIpUrls() {
            return this.nonIpHostnames.flatMap(toUrlArray);
        },
    };
};
exports.filledAddress = filledAddress;
const makeInterfaceFilled = async ({ effects, id, packageId, callback, }) => {
    const serviceInterfaceValue = await effects.getServiceInterface({
        serviceInterfaceId: id,
        packageId,
        callback,
    });
    if (!serviceInterfaceValue) {
        return null;
    }
    const hostId = serviceInterfaceValue.addressInfo.hostId;
    const host = await effects.getHostInfo({
        packageId,
        hostId,
        callback,
    });
    const interfaceFilled = {
        ...serviceInterfaceValue,
        host,
        addressInfo: host
            ? (0, exports.filledAddress)(host, serviceInterfaceValue.addressInfo)
            : null,
    };
    return interfaceFilled;
};
class GetServiceInterface {
    constructor(effects, opts) {
        this.effects = effects;
        this.opts = opts;
    }
    /**
     * Returns the requested service interface. Reruns the context from which it has been called if the underlying value changes
     */
    async const() {
        const { id, packageId } = this.opts;
        const callback = this.effects.constRetry &&
            (() => this.effects.constRetry && this.effects.constRetry());
        const interfaceFilled = await makeInterfaceFilled({
            effects: this.effects,
            id,
            packageId,
            callback,
        });
        return interfaceFilled;
    }
    /**
     * Returns the requested service interface. Does nothing if the value changes
     */
    async once() {
        const { id, packageId } = this.opts;
        const interfaceFilled = await makeInterfaceFilled({
            effects: this.effects,
            id,
            packageId,
        });
        return interfaceFilled;
    }
    async *watchGen(abort) {
        const { id, packageId } = this.opts;
        const resolveCell = { resolve: () => { } };
        this.effects.onLeaveContext(() => {
            resolveCell.resolve();
        });
        abort?.addEventListener("abort", () => resolveCell.resolve());
        while (this.effects.isInContext && !abort?.aborted) {
            let callback = () => { };
            const waitForNext = new Promise((resolve) => {
                callback = resolve;
                resolveCell.resolve = resolve;
            });
            yield await makeInterfaceFilled({
                effects: this.effects,
                id,
                packageId,
                callback,
            });
            await waitForNext;
        }
    }
    /**
     * Watches the requested service interface. Returns an async iterator that yields whenever the value changes
     */
    watch(abort) {
        const ctrl = new AbortController();
        abort?.addEventListener("abort", () => ctrl.abort());
        return Drop_1.DropGenerator.of(this.watchGen(ctrl.signal), () => ctrl.abort());
    }
    /**
     * Watches the requested service interface. Takes a custom callback function to run whenever the value changes
     */
    onChange(callback) {
        ;
        (async () => {
            const ctrl = new AbortController();
            for await (const value of this.watch(ctrl.signal)) {
                try {
                    const res = await callback(value);
                    if (res.cancel) {
                        ctrl.abort();
                        break;
                    }
                }
                catch (e) {
                    console.error("callback function threw an error @ GetServiceInterface.onChange", e);
                }
            }
        })()
            .catch((e) => callback(null, e))
            .catch((e) => console.error("callback function threw an error @ GetServiceInterface.onChange", e));
    }
    /**
     * Watches the requested service interface. Returns when the predicate is true
     */
    waitFor(pred) {
        const ctrl = new AbortController();
        return Drop_1.DropPromise.of(Promise.resolve().then(async () => {
            for await (const next of this.watchGen(ctrl.signal)) {
                if (pred(next)) {
                    return next;
                }
            }
            return null;
        }), () => ctrl.abort());
    }
}
exports.GetServiceInterface = GetServiceInterface;
function getServiceInterface(effects, opts) {
    return new GetServiceInterface(effects, opts);
}
//# sourceMappingURL=getServiceInterface.js.map