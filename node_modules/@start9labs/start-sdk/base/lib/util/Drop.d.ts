declare const dropId: unique symbol;
export type DropRef = {
    [dropId]: number;
};
export declare abstract class Drop {
    private static weak;
    private static registry;
    private static idCtr;
    private dropId?;
    private dropRef?;
    protected constructor();
    protected register(): void;
    private weak;
    abstract onDrop(): void;
    drop(): void;
    leak(): this;
}
export declare class DropPromise<T> implements Promise<T> {
    private readonly promise;
    private static dropFns;
    private static registry;
    private static idCtr;
    private dropId;
    private dropRef;
    [Symbol.toStringTag]: string;
    private constructor();
    static of<T>(promise: Promise<T>, dropFn?: () => void): DropPromise<T>;
    static ref<T>(promise: Promise<T>, dropRef: DropRef): DropPromise<T>;
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined): Promise<TResult1 | TResult2>;
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null | undefined): Promise<T | TResult>;
    finally(onfinally?: (() => void) | null | undefined): Promise<T>;
}
export declare class DropGenerator<T = unknown, TReturn = any, TNext = unknown> implements AsyncGenerator<T, TReturn, TNext> {
    private readonly generator;
    private static dropFns;
    private static registry;
    private static idCtr;
    private dropId;
    private dropRef;
    [Symbol.asyncIterator]: () => this;
    private constructor();
    static of<T, TReturn, TNext>(generator: AsyncGenerator<T, TReturn, TNext>, dropFn?: () => void): DropGenerator<T, TReturn, TNext>;
    next(...args: [] | [TNext]): Promise<IteratorResult<T, TReturn>>;
    return(value: TReturn | PromiseLike<TReturn>): Promise<IteratorResult<T, TReturn>>;
    throw(e: any): Promise<IteratorResult<T, TReturn>>;
}
export {};
