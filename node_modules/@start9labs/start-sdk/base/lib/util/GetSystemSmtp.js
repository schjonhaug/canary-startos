"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetSystemSmtp = void 0;
const Drop_1 = require("./Drop");
class GetSystemSmtp {
    constructor(effects) {
        this.effects = effects;
    }
    /**
     * Returns the system SMTP credentials. Reruns the context from which it has been called if the underlying value changes
     */
    const() {
        return this.effects.getSystemSmtp({
            callback: this.effects.constRetry &&
                (() => this.effects.constRetry && this.effects.constRetry()),
        });
    }
    /**
     * Returns the system SMTP credentials. Does nothing if the credentials change
     */
    once() {
        return this.effects.getSystemSmtp({});
    }
    async *watchGen(abort) {
        const resolveCell = { resolve: () => { } };
        this.effects.onLeaveContext(() => {
            resolveCell.resolve();
        });
        abort?.addEventListener("abort", () => resolveCell.resolve());
        while (this.effects.isInContext && !abort?.aborted) {
            let callback = () => { };
            const waitForNext = new Promise((resolve) => {
                callback = resolve;
                resolveCell.resolve = resolve;
            });
            yield await this.effects.getSystemSmtp({
                callback: () => callback(),
            });
            await waitForNext;
        }
    }
    /**
     * Watches the system SMTP credentials. Returns an async iterator that yields whenever the value changes
     */
    watch(abort) {
        const ctrl = new AbortController();
        abort?.addEventListener("abort", () => ctrl.abort());
        return Drop_1.DropGenerator.of(this.watchGen(ctrl.signal), () => ctrl.abort());
    }
    /**
     * Watches the system SMTP credentials. Takes a custom callback function to run whenever the credentials change
     */
    onChange(callback) {
        ;
        (async () => {
            const ctrl = new AbortController();
            for await (const value of this.watch(ctrl.signal)) {
                try {
                    const res = await callback(value);
                    if (res.cancel) {
                        ctrl.abort();
                        break;
                    }
                }
                catch (e) {
                    console.error("callback function threw an error @ GetSystemSmtp.onChange", e);
                }
            }
        })()
            .catch((e) => callback(null, e))
            .catch((e) => console.error("callback function threw an error @ GetSystemSmtp.onChange", e));
    }
    /**
     * Watches the system SMTP credentials. Returns when the predicate is true
     */
    waitFor(pred) {
        const ctrl = new AbortController();
        return Drop_1.DropPromise.of(Promise.resolve().then(async () => {
            for await (const next of this.watchGen(ctrl.signal)) {
                if (pred(next)) {
                    return next;
                }
            }
            return null;
        }), () => ctrl.abort());
    }
}
exports.GetSystemSmtp = GetSystemSmtp;
//# sourceMappingURL=GetSystemSmtp.js.map