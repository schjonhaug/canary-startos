"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Origin = void 0;
class Origin {
    constructor(host, internalPort, scheme, sslScheme) {
        this.host = host;
        this.internalPort = internalPort;
        this.scheme = scheme;
        this.sslScheme = sslScheme;
    }
    build({ username, path, query: search, schemeOverride, }) {
        const qpEntries = Object.entries(search)
            .map(([key, val]) => `${encodeURIComponent(key)}=${encodeURIComponent(val)}`)
            .join("&");
        const qp = qpEntries.length ? `?${qpEntries}` : "";
        return {
            hostId: this.host.options.id,
            internalPort: this.internalPort,
            scheme: schemeOverride ? schemeOverride.noSsl : this.scheme,
            sslScheme: schemeOverride ? schemeOverride.ssl : this.sslScheme,
            suffix: `${path}${qp}`,
            username,
        };
    }
    /**
     * @description A function to register a group of origins (<PROTOCOL> :// <HOSTNAME> : <PORT>) with StartOS
     *
     *   The returned addressReceipt serves as proof that the addresses were registered
     *
     * @param addressInfo
     * @returns
     */
    async export(serviceInterfaces) {
        const addressesInfo = [];
        for (let serviceInterface of serviceInterfaces) {
            const { name, description, id, type, username, path, query: search, schemeOverride, masked, } = serviceInterface.options;
            const addressInfo = this.build({
                username,
                path,
                query: search,
                schemeOverride,
            });
            await serviceInterface.options.effects.exportServiceInterface({
                id,
                name,
                description,
                addressInfo,
                type,
                masked,
            });
            addressesInfo.push(addressInfo);
        }
        return addressesInfo;
    }
}
exports.Origin = Origin;
//# sourceMappingURL=Origin.js.map