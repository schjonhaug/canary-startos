import { DeepMap } from "deep-equality-data-structures";
import * as P from "./exver";
export type ValidateVersion<T extends String> = T extends `-${infer A}` ? never : T extends `${infer A}-${string}` ? ValidateVersion<A> : T extends `${bigint}` ? unknown : T extends `${bigint}.${infer A}` ? ValidateVersion<A> : never;
export type ValidateExVer<T extends string> = T extends `#${string}:${infer A}:${infer B}` ? ValidateVersion<A> & ValidateVersion<B> : T extends `${infer A}:${infer B}` ? ValidateVersion<A> & ValidateVersion<B> : never;
export type ValidateExVers<T> = T extends [] ? unknown[] : T extends [infer A, ...infer B] ? ValidateExVer<A & string> & ValidateExVers<B> : never[];
type Anchor = {
    type: "Anchor";
    operator: P.CmpOp;
    version: ExtendedVersion;
};
type And = {
    type: "And";
    left: VersionRange;
    right: VersionRange;
};
type Or = {
    type: "Or";
    left: VersionRange;
    right: VersionRange;
};
type Not = {
    type: "Not";
    value: VersionRange;
};
type Flavor = {
    type: "Flavor";
    flavor: string | null;
};
type FlavorNot = {
    type: "FlavorNot";
    flavors: Set<string | null>;
};
type FlavorAtom = Flavor | FlavorNot;
/**
 * Splits a number line of versions in half, so that every possible semver is either to the left or right.
 * The `side` field handles inclusively.
 *
 * # Example
 * Consider the version `1.2.3`. For side=-1 the version point is like `1.2.2.999*.999*.**` (that is, 1.2.3.0.0.** is greater) and
 * for side=+1 the point is like `1.2.3.0.0.**.1` (that is, 1.2.3.0.0.** is less).
 */
type VersionRangePoint = {
    upstream: Version;
    downstream: Version;
    side: -1 | 1;
};
/**
 * Truth tables for version numbers and flavors. For each flavor we need a separate table, which
 * is quite straightforward. But in order to exhaustively enumerate the boolean values of every
 * combination of flavors and versions we also need tables for flavor negations.
 */
type VersionRangeTables = DeepMap<FlavorAtom, VersionRangeTable> | boolean;
/**
 * A truth table for version numbers. This is easiest to picture as a number line, cut up into
 * ranges of versions between version points.
 */
declare class VersionRangeTable {
    protected points: Array<VersionRangePoint>;
    protected values: boolean[];
    private constructor();
    static zip(a: VersionRangeTable, b: VersionRangeTable, func: (a: boolean, b: boolean) => boolean): VersionRangeTable;
    /**
     * Creates a version table which is `true` for the given flavor, and `false` for any other flavor.
     */
    static eqFlavor(flavor: string | null): VersionRangeTables;
    /**
     * Creates a version table with exactly two ranges (to the left and right of the given point) and with `false` for any other flavor.
     * This is easiest to understand by looking at `VersionRange.tables`.
     */
    static cmpPoint(flavor: string | null, point: VersionRangePoint, left: boolean, right: boolean): VersionRangeTables;
    /**
     * Helper for `cmpPoint`.
     */
    static cmp(version: ExtendedVersion, side: -1 | 1, left: boolean, right: boolean): VersionRangeTables;
    static not(tables: VersionRangeTables): boolean | DeepMap<FlavorAtom, VersionRangeTable, FlavorAtom, VersionRangeTable>;
    static and(a_tables: VersionRangeTables, b_tables: VersionRangeTables): VersionRangeTables;
    static or(...in_tables: VersionRangeTables[]): VersionRangeTables;
    /**
     * If this is true for all versions or false for all versions, returen that value. Otherwise return null.
     */
    static collapse(tables: VersionRangeTables): boolean | null;
    /**
     * Expresses this truth table as a series of version range operators.
     * https://en.wikipedia.org/wiki/Canonical_normal_form#Minterms
     */
    static minterms(tables: VersionRangeTables): VersionRange;
}
export declare class VersionRange {
    atom: Anchor | And | Or | Not | P.Any | P.None | Flavor;
    constructor(atom: Anchor | And | Or | Not | P.Any | P.None | Flavor);
    toStringParens(parent: "And" | "Or" | "Not"): string;
    toString(): string;
    private static parseAtom;
    private static parseRange;
    static parse(range: string): VersionRange;
    static anchor(operator: P.CmpOp, version: ExtendedVersion): VersionRange;
    static flavor(flavor: string | null): VersionRange;
    static parseEmver(range: string): VersionRange;
    and(right: VersionRange): VersionRange;
    or(right: VersionRange): VersionRange;
    not(): VersionRange;
    static and(...xs: Array<VersionRange>): VersionRange;
    static or(...xs: Array<VersionRange>): VersionRange;
    static any(): VersionRange;
    static none(): VersionRange;
    satisfiedBy(version: Version | ExtendedVersion): boolean;
    tables(): VersionRangeTables;
    satisfiable(): boolean;
    intersects(other: VersionRange): boolean;
    normalize(): VersionRange;
}
export declare class Version {
    number: number[];
    prerelease: (string | number)[];
    constructor(number: number[], prerelease: (string | number)[]);
    toString(): string;
    compare(other: Version): "greater" | "equal" | "less";
    compareForSort(other: Version): -1 | 0 | 1;
    static parse(version: string): Version;
    satisfies(versionRange: VersionRange): boolean;
}
export declare class ExtendedVersion {
    flavor: string | null;
    upstream: Version;
    downstream: Version;
    constructor(flavor: string | null, upstream: Version, downstream: Version);
    toString(): string;
    compare(other: ExtendedVersion): "greater" | "equal" | "less" | null;
    compareLexicographic(other: ExtendedVersion): "greater" | "equal" | "less";
    compareForSort(other: ExtendedVersion): 1 | 0 | -1;
    greaterThan(other: ExtendedVersion): boolean;
    greaterThanOrEqual(other: ExtendedVersion): boolean;
    equals(other: ExtendedVersion): boolean;
    lessThan(other: ExtendedVersion): boolean;
    lessThanOrEqual(other: ExtendedVersion): boolean;
    static parse(extendedVersion: string): ExtendedVersion;
    static parseEmver(extendedVersion: string): ExtendedVersion;
    /**
     * Returns an ExtendedVersion with the Upstream major version version incremented by 1
     * and sets subsequent digits to zero.
     * If no non-zero upstream digit can be found the last upstream digit will be incremented.
     */
    incrementMajor(): ExtendedVersion;
    /**
     * Returns an ExtendedVersion with the Upstream minor version version incremented by 1
     * also sets subsequent digits to zero.
     * If no non-zero upstream digit can be found the last digit will be incremented.
     */
    incrementMinor(): ExtendedVersion;
    /**
     * Returns a boolean indicating whether a given version satisfies the VersionRange
     * !( >= 1:1 <= 2:2) || <=#bitcoin:1.2.0-alpha:0
     */
    satisfies(versionRange: VersionRange): boolean;
}
export declare const testTypeExVer: <T extends string>(t: T & ValidateExVer<T>) => T & ValidateExVer<T>;
export declare const testTypeVersion: <T extends string>(t: T & ValidateVersion<T>) => T & ValidateVersion<T>;
export {};
