"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.S9pk = void 0;
exports.compare = compare;
const merkleArchive_1 = require("./merkleArchive");
const mime_1 = __importDefault(require("mime"));
const directoryContents_1 = require("./merkleArchive/directoryContents");
const fileContents_1 = require("./merkleArchive/fileContents");
const magicAndVersion = new Uint8Array([59, 59, 2]);
function compare(a, b) {
    if (a.length !== b.length)
        return false;
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i])
            return false;
    }
    return true;
}
class S9pk {
    constructor(manifest, archive, size) {
        this.manifest = manifest;
        this.archive = archive;
        this.size = size;
    }
    static async deserialize(source, commitment) {
        const header = new merkleArchive_1.ArrayBufferReader(await source
            .slice(0, magicAndVersion.length + merkleArchive_1.MerkleArchive.headerSize)
            .arrayBuffer());
        const magicVersion = new Uint8Array(header.next(magicAndVersion.length));
        if (!compare(magicVersion, magicAndVersion)) {
            throw new Error("Invalid Magic or Unexpected Version");
        }
        const archive = await merkleArchive_1.MerkleArchive.deserialize(source, "s9pk", header, commitment);
        const manifest = JSON.parse(new TextDecoder().decode(await archive.contents
            .getPath(["manifest.json"])
            ?.verifiedFileContents()));
        return new S9pk(manifest, archive, source.size);
    }
    async icon() {
        const iconName = Object.keys(this.archive.contents.contents).find((name) => name.startsWith("icon.") && mime_1.default.getType(name)?.startsWith("image/"));
        if (!iconName) {
            throw new Error("no icon found in archive");
        }
        return (`data:${mime_1.default.getType(iconName)};base64,` +
            Buffer.from(await this.archive.contents.getPath([iconName]).verifiedFileContents()).toString("base64"));
    }
    async dependencyMetadataFor(id) {
        const entry = this.archive.contents.getPath([
            "dependencies",
            id,
            "metadata.json",
        ]);
        if (!entry)
            return null;
        return JSON.parse(new TextDecoder().decode(await entry.verifiedFileContents()));
    }
    async dependencyIconFor(id) {
        const dir = this.archive.contents.getPath(["dependencies", id]);
        if (!dir || !(dir.contents instanceof directoryContents_1.DirectoryContents))
            return null;
        const iconName = Object.keys(dir.contents.contents).find((name) => name.startsWith("icon.") && mime_1.default.getType(name)?.startsWith("image/"));
        if (!iconName)
            return null;
        return (`data:${mime_1.default.getType(iconName)};base64,` +
            Buffer.from(await dir.contents.getPath([iconName]).verifiedFileContents()).toString("base64"));
    }
    async dependencyMetadata() {
        return Object.fromEntries(await Promise.all(Object.entries(this.manifest.dependencies)
            .filter(([_, info]) => !!info)
            .map(async ([id, info]) => [
            id,
            {
                ...(await this.dependencyMetadataFor(id)),
                icon: await this.dependencyIconFor(id),
                description: info.description,
                optional: info.optional,
            },
        ])));
    }
    async license() {
        const file = this.archive.contents.getPath(["LICENSE.md"]);
        if (!file || !(file.contents instanceof fileContents_1.FileContents))
            throw new Error("license.md not found in archive");
        return new TextDecoder().decode(await file.verifiedFileContents());
    }
}
exports.S9pk = S9pk;
//# sourceMappingURL=index.js.map