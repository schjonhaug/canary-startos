import { Comparable } from './comparable';
import { Normalized } from './normalizer';
import { Options } from './options';
/**
 * A Map implementation that supports deep equality for object keys.
 */
export declare class DeepMap<K, V, TxK = K, TxV = V> extends Map<K, V> implements Comparable<DeepMap<K, V, TxK, TxV>> {
    private options;
    private readonly normalizer;
    private readonly map;
    /**
     * @param entries optional list of key-value pairs to initialize the map
     * @param options configuration options
     */
    constructor(entries?: readonly (readonly [K, V])[] | null, options?: Options<K, V, TxK, TxV>);
    /**
     * Getter for number of kev-value pairs in the map.
     * @inheritdoc
     */
    get size(): number;
    /**
     * Returns true if the given key is present in the map.
     * @inheritdoc
     */
    has(key: K): boolean;
    /**
     * @inheritdoc
     */
    set(key: K, val: V): this;
    /**
     * @inheritdoc
     */
    get(key: K): V | undefined;
    /**
     * @inheritdoc
     */
    delete(key: K): boolean;
    /**
     * Clear all key-value pairs from the map.
     * @inheritdoc
     */
    clear(): void;
    /**
     * @inheritdoc
     */
    forEach(callbackfn: (val: V, key: K, map: Map<K, V>) => void): void;
    /**
     * @yields the next key-value pair in the map
     * @inheritdoc
     */
    [Symbol.iterator](): IterableIterator<[K, V]>;
    /**
     * @yields the next key-value pair in the map
     * @inheritdoc
     */
    entries(): IterableIterator<[K, V]>;
    /**
     * @inheritdoc
     */
    keys(): IterableIterator<K>;
    /**
     * @inheritdoc
     */
    values(): IterableIterator<V>;
    /**
     * @param other the map to compare against
     * @returns true if the entries of `other` are the same as this map
     */
    equals(other: this): boolean;
    /**
     * @param other the map to compare against
     * @returns true if the entries of `other` are all contained in this map
     */
    contains(other: this): boolean;
    /**
     * @param other the map to compare against
     * @returns a new map whose keys are the union of keys between `this` and `other` maps.
     *
     * NOTE: If both maps prescribe the same key, the key-value pair from `this` will be retained.
     */
    union(other: this): DeepMap<K, V, TxK, TxV>;
    /**
     * @param other the map to compare against
     * @returns a new map containing all key-value pairs in `this` that are also present in `other`.
     */
    intersection(other: this): DeepMap<K, V, TxK, TxV>;
    /**
     * @param other the map to compare against
     * @returns a new map containing all key-value pairs in `this` that are not present in `other`.
     */
    difference(other: this): DeepMap<K, V, TxK, TxV>;
    protected normalizeKey(input: K): Normalized<TxK>;
    protected normalizeValue(input: V): Normalized<TxV>;
    private validateUsingSameOptionsAs;
    /**
     * @returns true if the key is present in the provided map w/ the specified value
     */
    private keyValuePairIsPresentIn;
}
